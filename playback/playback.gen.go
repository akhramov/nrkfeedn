// Package playback provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package playback

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for AvailabilityLabel.
const (
	AvailabilityLabelAv        AvailabilityLabel = "Av"
	AvailabilityLabelSynstolk  AvailabilityLabel = "Synstolk"
	AvailabilityLabelTegnspråk AvailabilityLabel = "Tegnspråk"
)

// Defines values for ConvivaContentType.
const (
	Channel ConvivaContentType = "Channel"
	Clip    ConvivaContentType = "Clip"
	Event   ConvivaContentType = "Event"
	Podcast ConvivaContentType = "Podcast"
	Program ConvivaContentType = "Program"
)

// Defines values for ConvivaMediaType.
const (
	ConvivaMediaTypeAudio ConvivaMediaType = "Audio"
	ConvivaMediaTypeVideo ConvivaMediaType = "Video"
)

// Defines values for ConvivaStreamType.
const (
	LIVE ConvivaStreamType = "LIVE"
	VOD  ConvivaStreamType = "VOD"
)

// Defines values for DeviceGroupName.
const (
	Desktop    DeviceGroupName = "Desktop"
	Mobile     DeviceGroupName = "Mobile"
	SetTopUnit DeviceGroupName = "SetTopUnit"
	Tablet     DeviceGroupName = "Tablet"
	Tv         DeviceGroupName = "Tv"
)

// Defines values for DisplayAspectRatio.
const (
	N11  DisplayAspectRatio = "1:1"
	N169 DisplayAspectRatio = "16:9"
	N23  DisplayAspectRatio = "2:3"
	N43  DisplayAspectRatio = "4:3"
	N916 DisplayAspectRatio = "9:16"
)

// Defines values for DistributionFormat.
const (
	Dash                DistributionFormat = "Dash"
	Hds                 DistributionFormat = "Hds"
	Hls                 DistributionFormat = "Hls"
	ProgressiveDownload DistributionFormat = "ProgressiveDownload"
	ProgressiveMp3      DistributionFormat = "ProgressiveMp3"
)

// Defines values for LegalAgeBodyExemptStatus.
const (
	Exempt LegalAgeBodyExemptStatus = "exempt"
)

// Defines values for LegalAgeBodyRatedStatus.
const (
	Rated LegalAgeBodyRatedStatus = "rated"
)

// Defines values for LiveBufferType.
const (
	Fixed   LiveBufferType = "fixed"
	Growing LiveBufferType = "growing"
	None    LiveBufferType = "none"
	Sliding LiveBufferType = "sliding"
)

// Defines values for ManifestLinkName.
const (
	ManifestLinkNameDefault  ManifestLinkName = "default"
	ManifestLinkNameSynstolk ManifestLinkName = "synstolk"
	ManifestLinkNameTegntolk ManifestLinkName = "tegntolk"
)

// Defines values for NextLinkName.
const (
	Next NextLinkName = "next"
)

// Defines values for NonPlayableManifestLinksMetadataName.
const (
	NonPlayableManifestLinksMetadataNameMetadata NonPlayableManifestLinksMetadataName = "metadata"
)

// Defines values for NonPlayableManifestPlayability.
const (
	NonPlayableManifestPlayabilityNonPlayable NonPlayableManifestPlayability = "nonPlayable"
)

// Defines values for NonPlayableMessageType.
const (
	ChannelIsGeoblocked        NonPlayableMessageType = "ChannelIsGeoblocked"
	ChannelUnavailable         NonPlayableMessageType = "ChannelUnavailable"
	NoMessage                  NonPlayableMessageType = "NoMessage"
	ProgramIsGeoblocked        NonPlayableMessageType = "ProgramIsGeoblocked"
	ProgramIsInLiveBuffer      NonPlayableMessageType = "ProgramIsInLiveBuffer"
	ProgramIsNotTranscoded     NonPlayableMessageType = "ProgramIsNotTranscoded"
	ProgramRightsHasExpired    NonPlayableMessageType = "ProgramRightsHasExpired"
	ProgramRightsHasNotStarted NonPlayableMessageType = "ProgramRightsHasNotStarted"
	ProgramUnavailable         NonPlayableMessageType = "ProgramUnavailable"
)

// Defines values for NonPlayableMetadataLinksProgressTemplated.
const (
	NonPlayableMetadataLinksProgressTemplatedTrue NonPlayableMetadataLinksProgressTemplated = true
)

// Defines values for NonPlayableMetadataPlayability.
const (
	NonPlayableMetadataPlayabilityNonPlayable NonPlayableMetadataPlayability = "nonPlayable"
)

// Defines values for NonPlayableReason.
const (
	Blocked        NonPlayableReason = "blocked"
	Notransmission NonPlayableReason = "notransmission"
	Unavailable    NonPlayableReason = "unavailable"
)

// Defines values for PlayableFormat.
const (
	HDS PlayableFormat = "HDS"
	HLS PlayableFormat = "HLS"
	MP4 PlayableFormat = "MP4"
)

// Defines values for PlayableManifestLinksMetadataName.
const (
	PlayableManifestLinksMetadataNameMetadata PlayableManifestLinksMetadataName = "metadata"
)

// Defines values for PlayableManifestPlayability.
const (
	PlayableManifestPlayabilityPlayable PlayableManifestPlayability = "playable"
)

// Defines values for PlayableMetadataLinksProgressTemplated.
const (
	PlayableMetadataLinksProgressTemplatedTrue PlayableMetadataLinksProgressTemplated = true
)

// Defines values for PlayableMetadataPlayability.
const (
	PlayableMetadataPlayabilityPlayable PlayableMetadataPlayability = "playable"
)

// Defines values for PlayableMimeType.
const (
	ApplicationadobeF4m        PlayableMimeType = "application/adobe-f4m"
	Applicationmp4             PlayableMimeType = "application/mp4"
	ApplicationvndAppleMpegurl PlayableMimeType = "application/vnd.apple.mpegurl"
	Audiomp4                   PlayableMimeType = "audio/mp4"
	Videomp4                   PlayableMimeType = "video/mp4"
)

// Defines values for PlayableSourceMedium.
const (
	PlayableSourceMediumAudio PlayableSourceMedium = "audio"
	PlayableSourceMediumVideo PlayableSourceMedium = "video"
)

// Defines values for PlayableStreamingMode.
const (
	Live     PlayableStreamingMode = "live"
	OnDemand PlayableStreamingMode = "onDemand"
)

// Defines values for PlaybackDataVmCustomManifestParameters.
const (
	AudioOnly               PlaybackDataVmCustomManifestParameters = "AudioOnly"
	DolbyOnly               PlaybackDataVmCustomManifestParameters = "DolbyOnly"
	IFramePlaylist          PlaybackDataVmCustomManifestParameters = "IFramePlaylist"
	MuxAudio                PlaybackDataVmCustomManifestParameters = "MuxAudio"
	NoAudioOnly             PlaybackDataVmCustomManifestParameters = "NoAudioOnly"
	NoIFramePlaylist        PlaybackDataVmCustomManifestParameters = "NoIFramePlaylist"
	NoMuxAudi               PlaybackDataVmCustomManifestParameters = "NoMuxAudi"
	NoSignalDiscontinuities PlaybackDataVmCustomManifestParameters = "NoSignalDiscontinuities"
	SignalDiscontinuities   PlaybackDataVmCustomManifestParameters = "SignalDiscontinuities"
)

// Defines values for PlayerPlatform.
const (
	Altibox               PlayerPlatform = "Altibox"
	AltiboxHls            PlayerPlatform = "AltiboxHls"
	Android               PlayerPlatform = "Android"
	AndroidTv             PlayerPlatform = "AndroidTv"
	AppleTv               PlayerPlatform = "AppleTv"
	AppleTv4              PlayerPlatform = "AppleTv4"
	CanalDigitalKabelTv   PlayerPlatform = "CanalDigitalKabelTv"
	CanalDigitalSatellitt PlayerPlatform = "CanalDigitalSatellitt"
	Chromecast            PlayerPlatform = "Chromecast"
	ChromecastLegacy      PlayerPlatform = "ChromecastLegacy"
	GenericHls            PlayerPlatform = "GenericHls"
	Get                   PlayerPlatform = "Get"
	GoogleAssistant       PlayerPlatform = "GoogleAssistant"
	Ios                   PlayerPlatform = "Ios"
	Lg                    PlayerPlatform = "Lg"
	LgLegacy              PlayerPlatform = "LgLegacy"
	LgNetcast             PlayerPlatform = "LgNetcast"
	Ludo                  PlayerPlatform = "Ludo"
	Panasonic             PlayerPlatform = "Panasonic"
	Philips               PlayerPlatform = "Philips"
	PlayStation3          PlayerPlatform = "PlayStation3"
	PlayStation4          PlayerPlatform = "PlayStation4"
	RiksTv                PlayerPlatform = "RiksTv"
	SamsungOrsay          PlayerPlatform = "SamsungOrsay"
	SamsungTizen          PlayerPlatform = "SamsungTizen"
	Sony                  PlayerPlatform = "Sony"
	TelenorKabelTv        PlayerPlatform = "TelenorKabelTv"
	TelenorLegacyKabelTv  PlayerPlatform = "TelenorLegacyKabelTv"
	WindowsPhone          PlayerPlatform = "WindowsPhone"
	WindowsPhone8         PlayerPlatform = "WindowsPhone8"
	WorkStationHls        PlayerPlatform = "WorkStationHls"
)

// Defines values for SeriesLinkName.
const (
	Series SeriesLinkName = "series"
)

// Defines values for SubtitleLabel.
const (
	English                  SubtitleLabel = "English"
	NorskTekst               SubtitleLabel = "Norsk tekst"
	TekstetForHørselshemmede SubtitleLabel = "Tekstet for hørselshemmede"
)

// Defines values for SubtitleLanguage.
const (
	En SubtitleLanguage = "en"
	Nb SubtitleLanguage = "nb"
)

// Defines values for SubtitleType.
const (
	Gbr SubtitleType = "gbr"
	Mix SubtitleType = "mix"
	Nor SubtitleType = "nor"
	Ttv SubtitleType = "ttv"
)

// Defines values for SubtitlesDistribution.
const (
	Manifest    SubtitlesDistribution = "Manifest"
	NoSubtitles SubtitlesDistribution = "NoSubtitles"
	Sideload    SubtitlesDistribution = "Sideload"
)

// Defines values for GetPlaybackProgramManifestParamsOffline.
const (
	High     GetPlaybackProgramManifestParamsOffline = "high"
	Standard GetPlaybackProgramManifestParamsOffline = "standard"
)

// AvailabilityLabel defines model for AvailabilityLabel.
type AvailabilityLabel string

// AvailabilityVm defines model for AvailabilityVm.
type AvailabilityVm struct {
	ExternalEmbeddingAllowed bool `json:"externalEmbeddingAllowed"`

	// Information Standardized text about the availability of the media element.
	Information string `json:"information"`

	// IsGeoBlocked Indicates that the media element may not be played outside the range of
	// Norwegian IP addresses.
	IsGeoBlocked bool `json:"isGeoBlocked"`

	// Live Only applicable for live media elements. Will be null for on-demand media
	// elements.
	Live *AvailabilityVm_Live `json:"live"`

	// OnDemand Only applicable for on-demand media elements. Will be null for live media
	// elements.
	OnDemand *AvailabilityVm_OnDemand `json:"onDemand"`
}

// AvailabilityVm_Live Only applicable for live media elements. Will be null for on-demand media
// elements.
type AvailabilityVm_Live struct {
	union json.RawMessage
}

// AvailabilityVm_OnDemand Only applicable for on-demand media elements. Will be null for live media
// elements.
type AvailabilityVm_OnDemand struct {
	union json.RawMessage
}

// ConvivaContentType Type of content
type ConvivaContentType string

// ConvivaCustomProperties A string-to-string dictionary of custom metadata.
// When a property does not have a value, the string "None" should be used
type ConvivaCustomProperties struct {
	// ApplicationName Application name, set by player
	// Example: LudoHTML5PlayerAdapter (HTML5/Native HLS, hls.js, Flashls, ...)
	ApplicationName string `json:"applicationName"`

	// ApplicationVersion Application version number, set by player
	ApplicationVersion string `json:"applicationVersion"`

	// Category Main category of the content
	// Example: underholdning
	Category string `json:"category"`

	// CdnName Name of selected CDN
	// Example: Telenor-Cdn
	CdnName string `json:"cdnName"`

	// ContentId ContentId for current content
	// Example: DMTV23400617
	ContentId string `json:"contentId"`

	// ContentType Type of content
	ContentType ConvivaContentType `json:"contentType"`

	// Episode EpisodeNumber for current content
	// Not set for channels and content without series
	// Example: 5 (as string)
	Episode string `json:"episode"`

	// MediaType MediaType for current content
	MediaType ConvivaMediaType `json:"mediaType"`

	// Series Name of series
	// Not set for channels and content without series
	// Example: naar-kjemien-stemmer
	Series string `json:"series"`

	// ServiceName ServiceName, set by player
	// Example: tv.nrk.no, nrk.no, nrksuper.no
	ServiceName string `json:"serviceName"`

	// Title Title of current content
	// Example: smaken-av-den-rette
	Title string `json:"title"`
}

// ConvivaMediaType MediaType for current content
type ConvivaMediaType string

// ConvivaStatisticsVm defines model for ConvivaStatisticsVm.
type ConvivaStatisticsVm struct {
	// AssetName A unique, human-readable identifier for the content.
	// Example: DMTV23400617-smaken-av-den-rette
	AssetName string `json:"assetName"`

	// Custom A string-to-string dictionary of custom metadata.
	// When a property does not have a value, the string "None" should be used
	Custom ConvivaCustomProperties `json:"custom"`

	// Duration Duration of the video content. In seconds.
	// When duration is unknown, eg channels: -1
	Duration float32 `json:"duration"`

	// PlayerName A string identifying the current video application.
	// Example: Desktop-Ludo
	PlayerName string            `json:"playerName"`
	StreamType ConvivaStreamType `json:"streamType"`

	// StreamUrl The URL from where this video content will be downloaded. For
	// manifest-based streaming protocols, it should be the URL of the top-level
	// manifest.
	StreamUrl string `json:"streamUrl"`
}

// ConvivaStreamType defines model for ConvivaStreamType.
type ConvivaStreamType string

// DebugData defines model for DebugData.
type DebugData struct {
	Links struct {
		Self struct {
			Href string `json:"href"`
		} `json:"self"`
	} `json:"_links"`
	LocationData LocationDataVm `json:"locationData"`
	PlaybackData PlaybackDataVm `json:"playbackData"`
}

// DeviceGroupName defines model for DeviceGroupName.
type DeviceGroupName string

// DisplayAspectRatio defines model for DisplayAspectRatio.
type DisplayAspectRatio string

// DistributionFormat defines model for DistributionFormat.
type DistributionFormat string

// DnsList defines model for DnsList.
type DnsList struct {
	Links struct {
		Self struct {
			Href string `json:"href"`
		} `json:"self"`
	} `json:"_links"`

	// DomainNames Gets list of DomainNames used by applications
	DomainNames []string `json:"domainNames"`
}

// GoogleAnalyticsVm * dimension1: ID. KILDESYSTEM:UNIK_IDENTIFIKATOR
// * dimension2: Tittel
// * dimension3: Publiseringsår.
// * dimension4: Publiseringsmåned.
// * dimension5: Publiseringsdag. [01, 31]
// * dimension10: Kilde-ID
// * dimension21: Serie. Kun relevant for episoder/instalments.
// * dimension22: Episodenummer. Kun relevant for episoder (instalments?).
// * dimension23: Kategori
// * dimension25: Mediatype [video | audio]
// * dimension26: Mediakategori [live | ondemand]
// * dimension29: Platform
// [Ekstern doc](https://github.com/nrkno/analytics-docs/blob/master/docs/schema.md)
type GoogleAnalyticsVm map[string]string

// IndexPointVm defines model for IndexPointVm.
type IndexPointVm struct {
	// StartPoint IndexPoint Duration
	StartPoint string `json:"startPoint"`

	// Title IndexPoint title
	Title string `json:"title"`
}

// LegalAgeBodyExempt defines model for LegalAgeBodyExempt.
type LegalAgeBodyExempt struct {
	Status LegalAgeBodyExemptStatus `json:"status"`
}

// LegalAgeBodyExemptStatus defines model for LegalAgeBodyExempt.Status.
type LegalAgeBodyExemptStatus string

// LegalAgeBodyRated defines model for LegalAgeBodyRated.
type LegalAgeBodyRated struct {
	Rating LegalAgeRating          `json:"rating"`
	Status LegalAgeBodyRatedStatus `json:"status"`
}

// LegalAgeBodyRatedStatus defines model for LegalAgeBodyRated.Status.
type LegalAgeBodyRatedStatus string

// LegalAgeRating defines model for LegalAgeRating.
type LegalAgeRating struct {
	Code         string `json:"code"`
	DisplayAge   string `json:"displayAge"`
	DisplayValue string `json:"displayValue"`
}

// LegalAgeVm defines model for LegalAgeVm.
type LegalAgeVm struct {
	Body           LegalAgeVm_Body `json:"body"`
	LegalReference string          `json:"legalReference"`
}

// LegalAgeVm_Body defines model for LegalAgeVm.Body.
type LegalAgeVm_Body struct {
	union json.RawMessage
}

// LiveBufferType Type of liveBuffer
type LiveBufferType string

// LiveBufferVm defines model for LiveBufferVm.
type LiveBufferVm struct {
	// BufferDuration Live buffer length
	BufferDuration string `json:"bufferDuration"`

	// BufferStartTime Live buffer startTime
	BufferStartTime *string `json:"bufferStartTime"`

	// BufferType Type of liveBuffer
	BufferType LiveBufferType `json:"bufferType"`
}

// LiveTransmissionIntervalVm defines model for LiveTransmissionIntervalVm.
type LiveTransmissionIntervalVm struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// LocationDataVm defines model for LocationDataVm.
type LocationDataVm struct {
	ClientIpAddress           string `json:"clientIpAddress"`
	CountryCode               string `json:"countryCode"`
	ForwardedFor              string `json:"forwardedFor"`
	IsIpNorwegian             bool   `json:"isIpNorwegian"`
	OverriddenClientIpAddress string `json:"overriddenClientIpAddress"`
	OverriddenCountryCode     string `json:"overriddenCountryCode"`
	OverriddenLookupSource    string `json:"overriddenLookupSource"`
	RealIp                    string `json:"realIp"`
}

// LunaConfig defines model for LunaConfig.
type LunaConfig struct {
	Beacon string `json:"beacon"`
}

// LunaPayload defines model for LunaPayload.
type LunaPayload struct {
	Category      *string `json:"category"`
	CdnName       string  `json:"cdnName"`
	ContentLength *string `json:"contentLength"`
	DeliveryType  string  `json:"deliveryType"`
	Device        string  `json:"device"`
	PlayerId      string  `json:"playerId"`
	PlayerInfo    string  `json:"playerInfo"`
	Show          *string `json:"show"`
	Title         string  `json:"title"`
}

// LunaStatisticsVm defines model for LunaStatisticsVm.
type LunaStatisticsVm struct {
	Config LunaConfig  `json:"config"`
	Data   LunaPayload `json:"data"`
}

// ManifestLinkName defines model for ManifestLinkName.
type ManifestLinkName string

// ManifestResponse defines model for ManifestResponse.
type ManifestResponse struct {
	union json.RawMessage
}

// MediaUrlVm defines model for MediaUrlVm.
type MediaUrlVm struct {
	// Encrypted True if program is marked as HDSecure, false otherwise
	Encrypted bool `json:"encrypted"`

	// Format The video format for the resource identified by the URL.
	Format PlayableFormat `json:"format"`

	// MimeType The mimetype that corresponds to the specified format.
	MimeType PlayableMimeType `json:"mimeType"`

	// Url The media URL itself.
	Url string `json:"url"`
}

// MetadataResponse defines model for MetadataResponse.
type MetadataResponse struct {
	union json.RawMessage
}

// NextLink defines model for NextLink.
type NextLink struct {
	Href string       `json:"href"`
	Name NextLinkName `json:"name"`
}

// NextLinkName defines model for NextLink.Name.
type NextLinkName string

// NonPlayableElementVm defines model for NonPlayableElementVm.
type NonPlayableElementVm struct {
	// AvailableAbroadUrl URL to page with links to content available outside Norway (i.e. content that
	// isn't geo-blocked).
	AvailableAbroadUrl *string `json:"availableAbroadUrl"`

	// EndUserMessage Standard message for end user describing why the media element is not
	// playable.
	EndUserMessage string `json:"endUserMessage"`

	// HelpUrl URL to the help page referred to in the end user message.
	HelpUrl     string                 `json:"helpUrl"`
	MessageType NonPlayableMessageType `json:"messageType"`
	Reason      NonPlayableReason      `json:"reason"`
}

// NonPlayableManifest defines model for NonPlayableManifest.
type NonPlayableManifest struct {
	Links struct {
		Metadata struct {
			Href string                               `json:"href"`
			Name NonPlayableManifestLinksMetadataName `json:"name"`
		} `json:"metadata"`
		Self struct {
			Href string `json:"href"`
		} `json:"self"`
	} `json:"_links"`
	Availability       AvailabilityVm                 `json:"availability"`
	DisplayAspectRatio DisplayAspectRatio             `json:"displayAspectRatio"`
	Id                 string                         `json:"id"`
	NonPlayable        NonPlayableElementVm           `json:"nonPlayable"`
	Playability        NonPlayableManifestPlayability `json:"playability"`
	Playable           *interface{}                   `json:"playable"`
	SourceMedium       PlayableSourceMedium           `json:"sourceMedium"`
	Statistics         struct {
		Ga     *interface{} `json:"ga"`
		Luna   *interface{} `json:"luna"`
		Scores *interface{} `json:"scores"`
	} `json:"statistics"`
	StreamingMode PlayableStreamingMode `json:"streamingMode"`
}

// NonPlayableManifestLinksMetadataName defines model for NonPlayableManifest.Links.Metadata.Name.
type NonPlayableManifestLinksMetadataName string

// NonPlayableManifestPlayability defines model for NonPlayableManifest.Playability.
type NonPlayableManifestPlayability string

// NonPlayableMessageType defines model for NonPlayableMessageType.
type NonPlayableMessageType string

// NonPlayableMetadata defines model for NonPlayableMetadata.
type NonPlayableMetadata struct {
	Embedded struct {
		Manifests *NonPlayableMetadata_Embedded_Manifests `json:"manifests"`
	} `json:"_embedded"`
	Links struct {
		Manifests *NonPlayableMetadata_Links_Manifests `json:"manifests"`
		Next      *NonPlayableMetadata_Links_Next      `json:"next"`
		Progress  *struct {
			Href      string                                    `json:"href"`
			Templated NonPlayableMetadataLinksProgressTemplated `json:"templated"`
		} `json:"progress,omitempty"`
		Self struct {
			Href string `json:"href"`
		} `json:"self"`
		Series *SeriesLink `json:"series,omitempty"`
	} `json:"_links"`
	Availability       AvailabilityVm                      `json:"availability"`
	DisplayAspectRatio DisplayAspectRatio                  `json:"displayAspectRatio"`
	Duration           *string                             `json:"duration"`
	Id                 string                              `json:"id"`
	LegalAge           LegalAgeVm                          `json:"legalAge"`
	NonPlayable        NonPlayableElementVm                `json:"nonPlayable"`
	Playability        NonPlayableMetadataPlayability      `json:"playability"`
	Playable           *interface{}                        `json:"playable"`
	Preplay            PreplayVm                           `json:"preplay"`
	SkipDialogInfo     *NonPlayableMetadata_SkipDialogInfo `json:"skipDialogInfo"`
	SourceMedium       PlayableSourceMedium                `json:"sourceMedium"`
	StreamingMode      PlayableStreamingMode               `json:"streamingMode"`
}

// NonPlayableMetadataEmbeddedManifests0 defines model for .
type NonPlayableMetadataEmbeddedManifests0 = []struct {
	Links struct {
		Self struct {
			Href string           `json:"href"`
			Name ManifestLinkName `json:"name"`
		} `json:"self"`
	} `json:"_links"`
	AvailabilityLabel AvailabilityLabel `json:"availabilityLabel"`
	Id                string            `json:"id"`
}

// NonPlayableMetadata_Embedded_Manifests defines model for NonPlayableMetadata.Embedded.Manifests.
type NonPlayableMetadata_Embedded_Manifests struct {
	union json.RawMessage
}

// NonPlayableMetadataLinksManifests0 defines model for .
type NonPlayableMetadataLinksManifests0 = []struct {
	Href string           `json:"href"`
	Name ManifestLinkName `json:"name"`
}

// NonPlayableMetadata_Links_Manifests defines model for NonPlayableMetadata.Links.Manifests.
type NonPlayableMetadata_Links_Manifests struct {
	union json.RawMessage
}

// NonPlayableMetadata_Links_Next defines model for NonPlayableMetadata.Links.Next.
type NonPlayableMetadata_Links_Next struct {
	union json.RawMessage
}

// NonPlayableMetadataLinksProgressTemplated defines model for NonPlayableMetadata.Links.Progress.Templated.
type NonPlayableMetadataLinksProgressTemplated bool

// NonPlayableMetadataPlayability defines model for NonPlayableMetadata.Playability.
type NonPlayableMetadataPlayability string

// NonPlayableMetadata_SkipDialogInfo defines model for NonPlayableMetadata.SkipDialogInfo.
type NonPlayableMetadata_SkipDialogInfo struct {
	union json.RawMessage
}

// NonPlayableReason defines model for NonPlayableReason.
type NonPlayableReason string

// OnDemandUsageRights defines model for OnDemandUsageRights.
type OnDemandUsageRights struct {
	From         string `json:"from"`
	HasRightsNow bool   `json:"hasRightsNow"`
	To           string `json:"to"`
}

// PlayableElementVm defines model for PlayableElementVm.
type PlayableElementVm struct {
	// Assets List of mediaAssets
	Assets               []MediaUrlVm `json:"assets"`
	Duration             *string      `json:"duration"`
	EndSequenceStartTime *string      `json:"endSequenceStartTime"`

	// LiveBuffer Livebuffer if element is live
	LiveBuffer *PlayableElementVm_LiveBuffer `json:"liveBuffer"`

	// Subtitles List of subtitles
	Subtitles []SubtitlesVm `json:"subtitles"`
}

// PlayableElementVm_LiveBuffer Livebuffer if element is live
type PlayableElementVm_LiveBuffer struct {
	union json.RawMessage
}

// PlayableFormat The video format for the resource identified by the URL.
type PlayableFormat string

// PlayableManifest defines model for PlayableManifest.
type PlayableManifest struct {
	Links struct {
		Metadata struct {
			Href string                            `json:"href"`
			Name PlayableManifestLinksMetadataName `json:"name"`
		} `json:"metadata"`
		Self struct {
			Href string `json:"href"`
		} `json:"self"`
	} `json:"_links"`
	Availability       AvailabilityVm              `json:"availability"`
	DisplayAspectRatio DisplayAspectRatio          `json:"displayAspectRatio"`
	Id                 string                      `json:"id"`
	NonPlayable        *interface{}                `json:"nonPlayable"`
	Playability        PlayableManifestPlayability `json:"playability"`
	Playable           PlayableElementVm           `json:"playable"`
	SourceMedium       PlayableSourceMedium        `json:"sourceMedium"`
	Statistics         struct {
		Conviva ConvivaStatisticsVm `json:"conviva"`

		// Ga * dimension1: ID. KILDESYSTEM:UNIK_IDENTIFIKATOR
		// * dimension2: Tittel
		// * dimension3: Publiseringsår.
		// * dimension4: Publiseringsmåned.
		// * dimension5: Publiseringsdag. [01, 31]
		// * dimension10: Kilde-ID
		// * dimension21: Serie. Kun relevant for episoder/instalments.
		// * dimension22: Episodenummer. Kun relevant for episoder (instalments?).
		// * dimension23: Kategori
		// * dimension25: Mediatype [video | audio]
		// * dimension26: Mediakategori [live | ondemand]
		// * dimension29: Platform
		// [Ekstern doc](https://github.com/nrkno/analytics-docs/blob/master/docs/schema.md)
		Ga     GoogleAnalyticsVm  `json:"ga"`
		Luna   LunaStatisticsVm   `json:"luna"`
		Scores ScoresStatisticsVm `json:"scores"`
	} `json:"statistics"`
	StreamingMode PlayableStreamingMode `json:"streamingMode"`
}

// PlayableManifestLinksMetadataName defines model for PlayableManifest.Links.Metadata.Name.
type PlayableManifestLinksMetadataName string

// PlayableManifestPlayability defines model for PlayableManifest.Playability.
type PlayableManifestPlayability string

// PlayableMetadata defines model for PlayableMetadata.
type PlayableMetadata struct {
	Embedded struct {
		Manifests *PlayableMetadata_Embedded_Manifests `json:"manifests"`
	} `json:"_embedded"`
	Links struct {
		Manifests *PlayableMetadata_Links_Manifests `json:"manifests"`
		Next      *PlayableMetadata_Links_Next      `json:"next"`
		Progress  *struct {
			Href      string                                 `json:"href"`
			Templated PlayableMetadataLinksProgressTemplated `json:"templated"`
		} `json:"progress,omitempty"`
		Self struct {
			Href string `json:"href"`
		} `json:"self"`
		Series *SeriesLink `json:"series,omitempty"`
	} `json:"_links"`
	Availability       AvailabilityVm                   `json:"availability"`
	DisplayAspectRatio DisplayAspectRatio               `json:"displayAspectRatio"`
	Duration           *string                          `json:"duration"`
	Id                 string                           `json:"id"`
	LegalAge           LegalAgeVm                       `json:"legalAge"`
	NonPlayable        *interface{}                     `json:"nonPlayable"`
	Playability        PlayableMetadataPlayability      `json:"playability"`
	Playable           PlayableMetadataVm               `json:"playable"`
	Preplay            PreplayVm                        `json:"preplay"`
	SkipDialogInfo     *PlayableMetadata_SkipDialogInfo `json:"skipDialogInfo"`
	SourceMedium       PlayableSourceMedium             `json:"sourceMedium"`
	StreamingMode      PlayableStreamingMode            `json:"streamingMode"`
}

// PlayableMetadataEmbeddedManifests0 defines model for .
type PlayableMetadataEmbeddedManifests0 = []struct {
	Links struct {
		Self struct {
			Href string           `json:"href"`
			Name ManifestLinkName `json:"name"`
		} `json:"self"`
	} `json:"_links"`
	AvailabilityLabel AvailabilityLabel `json:"availabilityLabel"`
	Id                string            `json:"id"`
}

// PlayableMetadata_Embedded_Manifests defines model for PlayableMetadata.Embedded.Manifests.
type PlayableMetadata_Embedded_Manifests struct {
	union json.RawMessage
}

// PlayableMetadataLinksManifests0 defines model for .
type PlayableMetadataLinksManifests0 = []struct {
	Href string           `json:"href"`
	Name ManifestLinkName `json:"name"`
}

// PlayableMetadata_Links_Manifests defines model for PlayableMetadata.Links.Manifests.
type PlayableMetadata_Links_Manifests struct {
	union json.RawMessage
}

// PlayableMetadata_Links_Next defines model for PlayableMetadata.Links.Next.
type PlayableMetadata_Links_Next struct {
	union json.RawMessage
}

// PlayableMetadataLinksProgressTemplated defines model for PlayableMetadata.Links.Progress.Templated.
type PlayableMetadataLinksProgressTemplated bool

// PlayableMetadataPlayability defines model for PlayableMetadata.Playability.
type PlayableMetadataPlayability string

// PlayableMetadata_SkipDialogInfo defines model for PlayableMetadata.SkipDialogInfo.
type PlayableMetadata_SkipDialogInfo struct {
	union json.RawMessage
}

// PlayableMetadataVm defines model for PlayableMetadataVm.
type PlayableMetadataVm struct {
	// Resolve Uri to resolve to get the media manifest
	Resolve string `json:"resolve"`
}

// PlayableMimeType The mimetype that corresponds to the specified format.
type PlayableMimeType string

// PlayableSourceMedium defines model for PlayableSourceMedium.
type PlayableSourceMedium string

// PlayableStreamingMode defines model for PlayableStreamingMode.
type PlayableStreamingMode string

// PlaybackDataVm defines model for PlaybackDataVm.
type PlaybackDataVm struct {
	AppVersion               string                                   `json:"appVersion"`
	CedexisDeviceId          string                                   `json:"cedexisDeviceId"`
	CustomManifestParameters []PlaybackDataVmCustomManifestParameters `json:"customManifestParameters"`
	DeviceGroupName          DeviceGroupName                          `json:"deviceGroupName"`
	DistributionFormat       DistributionFormat                       `json:"distributionFormat"`
	IsBeta                   bool                                     `json:"isBeta"`
	MaxBitrate               float32                                  `json:"maxBitrate"`
	MinBitrate               float32                                  `json:"minBitrate"`
	OriginalUa               string                                   `json:"originalUa"`
	OsVersion                string                                   `json:"osVersion"`
	PlayerPlatform           PlayerPlatform                           `json:"playerPlatform"`
	SpringStreamContentType  string                                   `json:"springStreamContentType"`
	StartBitrate             float32                                  `json:"startBitrate"`
	SubtitlesDistribution    SubtitlesDistribution                    `json:"subtitlesDistribution"`
	UseNepOriginLive         bool                                     `json:"useNepOriginLive"`
	UseNepOriginOdm          bool                                     `json:"useNepOriginOdm"`
	WurflId                  *string                                  `json:"wurflId"`
}

// PlaybackDataVmCustomManifestParameters defines model for PlaybackDataVm.CustomManifestParameters.
type PlaybackDataVmCustomManifestParameters string

// PlayerPlatform defines model for PlayerPlatform.
type PlayerPlatform string

// PosterImageVm defines model for PosterImageVm.
type PosterImageVm struct {
	PixelWidth float32 `json:"pixelWidth"`
	Url        string  `json:"url"`
}

// PosterVm Image to show before play
type PosterVm struct {
	// Images List of images in different sizes
	Images []PosterImageVm `json:"images"`
}

// PreplayVm defines model for PreplayVm.
type PreplayVm struct {
	// Description Description to show before play
	Description string `json:"description"`

	// IndexPoints List of index points
	IndexPoints []IndexPointVm `json:"indexPoints"`

	// Poster Image to show before play
	Poster PosterVm `json:"poster"`

	// Titles Title to show before play
	Titles TitlesVm `json:"titles"`
}

// ScoresStatisticsVm defines model for ScoresStatisticsVm.
type ScoresStatisticsVm struct {
	SpringStreamContentType string `json:"springStreamContentType"`
	SpringStreamProgramId   string `json:"springStreamProgramId"`
	SpringStreamSite        string `json:"springStreamSite"`
	SpringStreamStream      string `json:"springStreamStream"`
}

// SeriesLink defines model for SeriesLink.
type SeriesLink struct {
	Href string         `json:"href"`
	Name SeriesLinkName `json:"name"`
}

// SeriesLinkName defines model for SeriesLink.Name.
type SeriesLinkName string

// SkipDialogInfoVm defines model for SkipDialogInfoVm.
type SkipDialogInfoVm struct {
	EndIntro              string  `json:"endIntro"`
	EndIntroInSeconds     float32 `json:"endIntroInSeconds"`
	StartCredits          string  `json:"startCredits"`
	StartCreditsInSeconds float32 `json:"startCreditsInSeconds"`
	StartIntro            string  `json:"startIntro"`
	StartIntroInSeconds   float32 `json:"startIntroInSeconds"`
}

// SubtitleLabel defines model for SubtitleLabel.
type SubtitleLabel string

// SubtitleLanguage defines model for SubtitleLanguage.
type SubtitleLanguage string

// SubtitleType defines model for SubtitleType.
type SubtitleType string

// SubtitlesDistribution defines model for SubtitlesDistribution.
type SubtitlesDistribution string

// SubtitlesVm defines model for SubtitlesVm.
type SubtitlesVm struct {
	DefaultOn bool             `json:"defaultOn"`
	Label     SubtitleLabel    `json:"label"`
	Language  SubtitleLanguage `json:"language"`
	Type      SubtitleType     `json:"type"`
	WebVtt    string           `json:"webVtt"`
}

// TitlesVm Title to show before play
type TitlesVm struct {
	Subtitle string `json:"subtitle"`
	Title    string `json:"title"`
}

// GetPlaybackChannelManifestParams defines parameters for GetPlaybackChannelManifest.
type GetPlaybackChannelManifestParams struct {
	// InSuperUniverse Is the client in in Super-universe or not. Used to get correct statistics and content
	InSuperUniverse *string `form:"inSuperUniverse,omitempty" json:"inSuperUniverse,omitempty"`

	// PreferredBandwidth PreferredBandwidth could be used to limit the number of qualities in the HLS manifest. Legal values: low, mid, high, auto
	PreferredBandwidth *string `form:"preferredBandwidth,omitempty" json:"preferredBandwidth,omitempty"`

	// PreferredCdn PreferredCdn could be used to get the CDN used in the last request. Overrides Cedexis. The value that should be passed in exists as a header, named: CdnName
	PreferredCdn *string `form:"preferredCdn,omitempty" json:"preferredCdn,omitempty"`
}

// GetPlaybackClipManifestParams defines parameters for GetPlaybackClipManifest.
type GetPlaybackClipManifestParams struct {
	// PreferredBandwidth PreferredBandwidth could be used to limit the number of qualities in the HLS manifest. Legal values: low, mid, high, auto
	PreferredBandwidth *string `form:"preferredBandwidth,omitempty" json:"preferredBandwidth,omitempty"`

	// PreferredCdn PreferredCdn could be used to get the CDN used in the last request. Overrides Cedexis. The value that should be passed in exists as a header, named: CdnName
	PreferredCdn *string `form:"preferredCdn,omitempty" json:"preferredCdn,omitempty"`
}

// GetPlaybackProgramManifestParams defines parameters for GetPlaybackProgramManifest.
type GetPlaybackProgramManifestParams struct {
	// InSuperUniverse Is the client in in Super-universe or not. Used to get correct statistics and content
	InSuperUniverse *string `form:"inSuperUniverse,omitempty" json:"inSuperUniverse,omitempty"`

	// PreferredBandwidth PreferredBandwidth could be used to limit the number of qualities in the HLS manifest. Legal values: low, mid, high, auto
	PreferredBandwidth *string `form:"preferredBandwidth,omitempty" json:"preferredBandwidth,omitempty"`

	// PreferredCdn PreferredCdn could be used to get the CDN used in the last request. Overrides Cedexis. The value that should be passed in exists as a header, named: CdnName
	PreferredCdn *string `form:"preferredCdn,omitempty" json:"preferredCdn,omitempty"`

	// Offline Used to request HLS manifest for offline. This overrides/ignores preferredBandwith. Tablet/phone information is pulled from User-Agent
	Offline *GetPlaybackProgramManifestParamsOffline `form:"offline,omitempty" json:"offline,omitempty"`
}

// GetPlaybackProgramManifestParamsOffline defines parameters for GetPlaybackProgramManifest.
type GetPlaybackProgramManifestParamsOffline string

// GetPlaybackManifestRedirectParams defines parameters for GetPlaybackManifestRedirect.
type GetPlaybackManifestRedirectParams struct {
	// InSuperUniverse Is the client in in Super-universe or not. Used to get correct statistics and content
	InSuperUniverse *string `form:"inSuperUniverse,omitempty" json:"inSuperUniverse,omitempty"`

	// PreferredBandwidth PreferredBandwidth could be used to limit the number of qualities in the HLS manifest. Legal values: low, mid, high, auto
	PreferredBandwidth *string `form:"preferredBandwidth,omitempty" json:"preferredBandwidth,omitempty"`

	// PreferredCdn PreferredCdn could be used to get the CDN used in the last request. Overrides Cedexis. The value that should be passed in exists as a header, named: CdnName
	PreferredCdn *string `form:"preferredCdn,omitempty" json:"preferredCdn,omitempty"`

	// Live2Vod Use to activate liveToVod on playback
	Live2Vod *string `form:"live2Vod,omitempty" json:"live2Vod,omitempty"`
}

// GetPlaybackMetadataRedirectParams defines parameters for GetPlaybackMetadataRedirect.
type GetPlaybackMetadataRedirectParams struct {
	// Live2Vod Use to activate liveToVod on playback
	Live2Vod *string `form:"live2Vod,omitempty" json:"live2Vod,omitempty"`
}

func (t AvailabilityVm_Live) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AvailabilityVm_Live) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOnDemandUsageRights returns the union data inside the AvailabilityVm_OnDemand as a OnDemandUsageRights
func (t AvailabilityVm_OnDemand) AsOnDemandUsageRights() (OnDemandUsageRights, error) {
	var body OnDemandUsageRights
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOnDemandUsageRights overwrites any union data inside the AvailabilityVm_OnDemand as the provided OnDemandUsageRights
func (t *AvailabilityVm_OnDemand) FromOnDemandUsageRights(v OnDemandUsageRights) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOnDemandUsageRights performs a merge with any union data inside the AvailabilityVm_OnDemand, using the provided OnDemandUsageRights
func (t *AvailabilityVm_OnDemand) MergeOnDemandUsageRights(v OnDemandUsageRights) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AvailabilityVm_OnDemand) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AvailabilityVm_OnDemand) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLegalAgeBodyExempt returns the union data inside the LegalAgeVm_Body as a LegalAgeBodyExempt
func (t LegalAgeVm_Body) AsLegalAgeBodyExempt() (LegalAgeBodyExempt, error) {
	var body LegalAgeBodyExempt
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegalAgeBodyExempt overwrites any union data inside the LegalAgeVm_Body as the provided LegalAgeBodyExempt
func (t *LegalAgeVm_Body) FromLegalAgeBodyExempt(v LegalAgeBodyExempt) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegalAgeBodyExempt performs a merge with any union data inside the LegalAgeVm_Body, using the provided LegalAgeBodyExempt
func (t *LegalAgeVm_Body) MergeLegalAgeBodyExempt(v LegalAgeBodyExempt) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsLegalAgeBodyRated returns the union data inside the LegalAgeVm_Body as a LegalAgeBodyRated
func (t LegalAgeVm_Body) AsLegalAgeBodyRated() (LegalAgeBodyRated, error) {
	var body LegalAgeBodyRated
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegalAgeBodyRated overwrites any union data inside the LegalAgeVm_Body as the provided LegalAgeBodyRated
func (t *LegalAgeVm_Body) FromLegalAgeBodyRated(v LegalAgeBodyRated) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegalAgeBodyRated performs a merge with any union data inside the LegalAgeVm_Body, using the provided LegalAgeBodyRated
func (t *LegalAgeVm_Body) MergeLegalAgeBodyRated(v LegalAgeBodyRated) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t LegalAgeVm_Body) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LegalAgeVm_Body) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlayableManifest returns the union data inside the ManifestResponse as a PlayableManifest
func (t ManifestResponse) AsPlayableManifest() (PlayableManifest, error) {
	var body PlayableManifest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlayableManifest overwrites any union data inside the ManifestResponse as the provided PlayableManifest
func (t *ManifestResponse) FromPlayableManifest(v PlayableManifest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlayableManifest performs a merge with any union data inside the ManifestResponse, using the provided PlayableManifest
func (t *ManifestResponse) MergePlayableManifest(v PlayableManifest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsNonPlayableManifest returns the union data inside the ManifestResponse as a NonPlayableManifest
func (t ManifestResponse) AsNonPlayableManifest() (NonPlayableManifest, error) {
	var body NonPlayableManifest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNonPlayableManifest overwrites any union data inside the ManifestResponse as the provided NonPlayableManifest
func (t *ManifestResponse) FromNonPlayableManifest(v NonPlayableManifest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNonPlayableManifest performs a merge with any union data inside the ManifestResponse, using the provided NonPlayableManifest
func (t *ManifestResponse) MergeNonPlayableManifest(v NonPlayableManifest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ManifestResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ManifestResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlayableMetadata returns the union data inside the MetadataResponse as a PlayableMetadata
func (t MetadataResponse) AsPlayableMetadata() (PlayableMetadata, error) {
	var body PlayableMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlayableMetadata overwrites any union data inside the MetadataResponse as the provided PlayableMetadata
func (t *MetadataResponse) FromPlayableMetadata(v PlayableMetadata) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlayableMetadata performs a merge with any union data inside the MetadataResponse, using the provided PlayableMetadata
func (t *MetadataResponse) MergePlayableMetadata(v PlayableMetadata) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsNonPlayableMetadata returns the union data inside the MetadataResponse as a NonPlayableMetadata
func (t MetadataResponse) AsNonPlayableMetadata() (NonPlayableMetadata, error) {
	var body NonPlayableMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNonPlayableMetadata overwrites any union data inside the MetadataResponse as the provided NonPlayableMetadata
func (t *MetadataResponse) FromNonPlayableMetadata(v NonPlayableMetadata) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNonPlayableMetadata performs a merge with any union data inside the MetadataResponse, using the provided NonPlayableMetadata
func (t *MetadataResponse) MergeNonPlayableMetadata(v NonPlayableMetadata) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t MetadataResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MetadataResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNonPlayableMetadataEmbeddedManifests0 returns the union data inside the NonPlayableMetadata_Embedded_Manifests as a NonPlayableMetadataEmbeddedManifests0
func (t NonPlayableMetadata_Embedded_Manifests) AsNonPlayableMetadataEmbeddedManifests0() (NonPlayableMetadataEmbeddedManifests0, error) {
	var body NonPlayableMetadataEmbeddedManifests0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNonPlayableMetadataEmbeddedManifests0 overwrites any union data inside the NonPlayableMetadata_Embedded_Manifests as the provided NonPlayableMetadataEmbeddedManifests0
func (t *NonPlayableMetadata_Embedded_Manifests) FromNonPlayableMetadataEmbeddedManifests0(v NonPlayableMetadataEmbeddedManifests0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNonPlayableMetadataEmbeddedManifests0 performs a merge with any union data inside the NonPlayableMetadata_Embedded_Manifests, using the provided NonPlayableMetadataEmbeddedManifests0
func (t *NonPlayableMetadata_Embedded_Manifests) MergeNonPlayableMetadataEmbeddedManifests0(v NonPlayableMetadataEmbeddedManifests0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t NonPlayableMetadata_Embedded_Manifests) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NonPlayableMetadata_Embedded_Manifests) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNonPlayableMetadataLinksManifests0 returns the union data inside the NonPlayableMetadata_Links_Manifests as a NonPlayableMetadataLinksManifests0
func (t NonPlayableMetadata_Links_Manifests) AsNonPlayableMetadataLinksManifests0() (NonPlayableMetadataLinksManifests0, error) {
	var body NonPlayableMetadataLinksManifests0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNonPlayableMetadataLinksManifests0 overwrites any union data inside the NonPlayableMetadata_Links_Manifests as the provided NonPlayableMetadataLinksManifests0
func (t *NonPlayableMetadata_Links_Manifests) FromNonPlayableMetadataLinksManifests0(v NonPlayableMetadataLinksManifests0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNonPlayableMetadataLinksManifests0 performs a merge with any union data inside the NonPlayableMetadata_Links_Manifests, using the provided NonPlayableMetadataLinksManifests0
func (t *NonPlayableMetadata_Links_Manifests) MergeNonPlayableMetadataLinksManifests0(v NonPlayableMetadataLinksManifests0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t NonPlayableMetadata_Links_Manifests) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NonPlayableMetadata_Links_Manifests) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNextLink returns the union data inside the NonPlayableMetadata_Links_Next as a NextLink
func (t NonPlayableMetadata_Links_Next) AsNextLink() (NextLink, error) {
	var body NextLink
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNextLink overwrites any union data inside the NonPlayableMetadata_Links_Next as the provided NextLink
func (t *NonPlayableMetadata_Links_Next) FromNextLink(v NextLink) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNextLink performs a merge with any union data inside the NonPlayableMetadata_Links_Next, using the provided NextLink
func (t *NonPlayableMetadata_Links_Next) MergeNextLink(v NextLink) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t NonPlayableMetadata_Links_Next) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NonPlayableMetadata_Links_Next) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSkipDialogInfoVm returns the union data inside the NonPlayableMetadata_SkipDialogInfo as a SkipDialogInfoVm
func (t NonPlayableMetadata_SkipDialogInfo) AsSkipDialogInfoVm() (SkipDialogInfoVm, error) {
	var body SkipDialogInfoVm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSkipDialogInfoVm overwrites any union data inside the NonPlayableMetadata_SkipDialogInfo as the provided SkipDialogInfoVm
func (t *NonPlayableMetadata_SkipDialogInfo) FromSkipDialogInfoVm(v SkipDialogInfoVm) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSkipDialogInfoVm performs a merge with any union data inside the NonPlayableMetadata_SkipDialogInfo, using the provided SkipDialogInfoVm
func (t *NonPlayableMetadata_SkipDialogInfo) MergeSkipDialogInfoVm(v SkipDialogInfoVm) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t NonPlayableMetadata_SkipDialogInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NonPlayableMetadata_SkipDialogInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLiveBufferVm returns the union data inside the PlayableElementVm_LiveBuffer as a LiveBufferVm
func (t PlayableElementVm_LiveBuffer) AsLiveBufferVm() (LiveBufferVm, error) {
	var body LiveBufferVm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLiveBufferVm overwrites any union data inside the PlayableElementVm_LiveBuffer as the provided LiveBufferVm
func (t *PlayableElementVm_LiveBuffer) FromLiveBufferVm(v LiveBufferVm) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLiveBufferVm performs a merge with any union data inside the PlayableElementVm_LiveBuffer, using the provided LiveBufferVm
func (t *PlayableElementVm_LiveBuffer) MergeLiveBufferVm(v LiveBufferVm) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PlayableElementVm_LiveBuffer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlayableElementVm_LiveBuffer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlayableMetadataEmbeddedManifests0 returns the union data inside the PlayableMetadata_Embedded_Manifests as a PlayableMetadataEmbeddedManifests0
func (t PlayableMetadata_Embedded_Manifests) AsPlayableMetadataEmbeddedManifests0() (PlayableMetadataEmbeddedManifests0, error) {
	var body PlayableMetadataEmbeddedManifests0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlayableMetadataEmbeddedManifests0 overwrites any union data inside the PlayableMetadata_Embedded_Manifests as the provided PlayableMetadataEmbeddedManifests0
func (t *PlayableMetadata_Embedded_Manifests) FromPlayableMetadataEmbeddedManifests0(v PlayableMetadataEmbeddedManifests0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlayableMetadataEmbeddedManifests0 performs a merge with any union data inside the PlayableMetadata_Embedded_Manifests, using the provided PlayableMetadataEmbeddedManifests0
func (t *PlayableMetadata_Embedded_Manifests) MergePlayableMetadataEmbeddedManifests0(v PlayableMetadataEmbeddedManifests0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PlayableMetadata_Embedded_Manifests) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlayableMetadata_Embedded_Manifests) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlayableMetadataLinksManifests0 returns the union data inside the PlayableMetadata_Links_Manifests as a PlayableMetadataLinksManifests0
func (t PlayableMetadata_Links_Manifests) AsPlayableMetadataLinksManifests0() (PlayableMetadataLinksManifests0, error) {
	var body PlayableMetadataLinksManifests0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlayableMetadataLinksManifests0 overwrites any union data inside the PlayableMetadata_Links_Manifests as the provided PlayableMetadataLinksManifests0
func (t *PlayableMetadata_Links_Manifests) FromPlayableMetadataLinksManifests0(v PlayableMetadataLinksManifests0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlayableMetadataLinksManifests0 performs a merge with any union data inside the PlayableMetadata_Links_Manifests, using the provided PlayableMetadataLinksManifests0
func (t *PlayableMetadata_Links_Manifests) MergePlayableMetadataLinksManifests0(v PlayableMetadataLinksManifests0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PlayableMetadata_Links_Manifests) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlayableMetadata_Links_Manifests) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNextLink returns the union data inside the PlayableMetadata_Links_Next as a NextLink
func (t PlayableMetadata_Links_Next) AsNextLink() (NextLink, error) {
	var body NextLink
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNextLink overwrites any union data inside the PlayableMetadata_Links_Next as the provided NextLink
func (t *PlayableMetadata_Links_Next) FromNextLink(v NextLink) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNextLink performs a merge with any union data inside the PlayableMetadata_Links_Next, using the provided NextLink
func (t *PlayableMetadata_Links_Next) MergeNextLink(v NextLink) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PlayableMetadata_Links_Next) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlayableMetadata_Links_Next) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSkipDialogInfoVm returns the union data inside the PlayableMetadata_SkipDialogInfo as a SkipDialogInfoVm
func (t PlayableMetadata_SkipDialogInfo) AsSkipDialogInfoVm() (SkipDialogInfoVm, error) {
	var body SkipDialogInfoVm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSkipDialogInfoVm overwrites any union data inside the PlayableMetadata_SkipDialogInfo as the provided SkipDialogInfoVm
func (t *PlayableMetadata_SkipDialogInfo) FromSkipDialogInfoVm(v SkipDialogInfoVm) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSkipDialogInfoVm performs a merge with any union data inside the PlayableMetadata_SkipDialogInfo, using the provided SkipDialogInfoVm
func (t *PlayableMetadata_SkipDialogInfo) MergeSkipDialogInfoVm(v SkipDialogInfoVm) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PlayableMetadata_SkipDialogInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlayableMetadata_SkipDialogInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetPlaybackDebug request
	GetPlaybackDebug(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackDnsList request
	GetPlaybackDnsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackChannelManifest request
	GetPlaybackChannelManifest(ctx context.Context, channelId string, params *GetPlaybackChannelManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackClipManifest request
	GetPlaybackClipManifest(ctx context.Context, clipId string, params *GetPlaybackClipManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackProgramManifest request
	GetPlaybackProgramManifest(ctx context.Context, programId string, params *GetPlaybackProgramManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackManifestRedirect request
	GetPlaybackManifestRedirect(ctx context.Context, id string, params *GetPlaybackManifestRedirectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackChannelMetadata request
	GetPlaybackChannelMetadata(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackClipMetadata request
	GetPlaybackClipMetadata(ctx context.Context, clipId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackProgramMetadata request
	GetPlaybackProgramMetadata(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackMetadataRedirect request
	GetPlaybackMetadataRedirect(ctx context.Context, id string, params *GetPlaybackMetadataRedirectParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetPlaybackDebug(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackDebugRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackDnsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackDnsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackChannelManifest(ctx context.Context, channelId string, params *GetPlaybackChannelManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackChannelManifestRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackClipManifest(ctx context.Context, clipId string, params *GetPlaybackClipManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackClipManifestRequest(c.Server, clipId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackProgramManifest(ctx context.Context, programId string, params *GetPlaybackProgramManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackProgramManifestRequest(c.Server, programId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackManifestRedirect(ctx context.Context, id string, params *GetPlaybackManifestRedirectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackManifestRedirectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackChannelMetadata(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackChannelMetadataRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackClipMetadata(ctx context.Context, clipId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackClipMetadataRequest(c.Server, clipId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackProgramMetadata(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackProgramMetadataRequest(c.Server, programId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackMetadataRedirect(ctx context.Context, id string, params *GetPlaybackMetadataRedirectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackMetadataRedirectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetPlaybackDebugRequest generates requests for GetPlaybackDebug
func NewGetPlaybackDebugRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/debug")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackDnsListRequest generates requests for GetPlaybackDnsList
func NewGetPlaybackDnsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/dnslist")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackChannelManifestRequest generates requests for GetPlaybackChannelManifest
func NewGetPlaybackChannelManifestRequest(server string, channelId string, params *GetPlaybackChannelManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/manifest/channel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.InSuperUniverse != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inSuperUniverse", runtime.ParamLocationQuery, *params.InSuperUniverse); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PreferredBandwidth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferredBandwidth", runtime.ParamLocationQuery, *params.PreferredBandwidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PreferredCdn != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferredCdn", runtime.ParamLocationQuery, *params.PreferredCdn); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackClipManifestRequest generates requests for GetPlaybackClipManifest
func NewGetPlaybackClipManifestRequest(server string, clipId string, params *GetPlaybackClipManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clipId", runtime.ParamLocationPath, clipId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/manifest/clip/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PreferredBandwidth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferredBandwidth", runtime.ParamLocationQuery, *params.PreferredBandwidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PreferredCdn != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferredCdn", runtime.ParamLocationQuery, *params.PreferredCdn); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackProgramManifestRequest generates requests for GetPlaybackProgramManifest
func NewGetPlaybackProgramManifestRequest(server string, programId string, params *GetPlaybackProgramManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "programId", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/manifest/program/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.InSuperUniverse != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inSuperUniverse", runtime.ParamLocationQuery, *params.InSuperUniverse); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PreferredBandwidth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferredBandwidth", runtime.ParamLocationQuery, *params.PreferredBandwidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PreferredCdn != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferredCdn", runtime.ParamLocationQuery, *params.PreferredCdn); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offline != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offline", runtime.ParamLocationQuery, *params.Offline); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackManifestRedirectRequest generates requests for GetPlaybackManifestRedirect
func NewGetPlaybackManifestRedirectRequest(server string, id string, params *GetPlaybackManifestRedirectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/manifest/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.InSuperUniverse != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inSuperUniverse", runtime.ParamLocationQuery, *params.InSuperUniverse); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PreferredBandwidth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferredBandwidth", runtime.ParamLocationQuery, *params.PreferredBandwidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PreferredCdn != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferredCdn", runtime.ParamLocationQuery, *params.PreferredCdn); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Live2Vod != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "live2Vod", runtime.ParamLocationQuery, *params.Live2Vod); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackChannelMetadataRequest generates requests for GetPlaybackChannelMetadata
func NewGetPlaybackChannelMetadataRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/metadata/channel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackClipMetadataRequest generates requests for GetPlaybackClipMetadata
func NewGetPlaybackClipMetadataRequest(server string, clipId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clipId", runtime.ParamLocationPath, clipId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/metadata/clip/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackProgramMetadataRequest generates requests for GetPlaybackProgramMetadata
func NewGetPlaybackProgramMetadataRequest(server string, programId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "programId", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/metadata/program/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackMetadataRedirectRequest generates requests for GetPlaybackMetadataRedirect
func NewGetPlaybackMetadataRedirectRequest(server string, id string, params *GetPlaybackMetadataRedirectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playback/metadata/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Live2Vod != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "live2Vod", runtime.ParamLocationQuery, *params.Live2Vod); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetPlaybackDebug request
	GetPlaybackDebugWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPlaybackDebugResponse, error)

	// GetPlaybackDnsList request
	GetPlaybackDnsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPlaybackDnsListResponse, error)

	// GetPlaybackChannelManifest request
	GetPlaybackChannelManifestWithResponse(ctx context.Context, channelId string, params *GetPlaybackChannelManifestParams, reqEditors ...RequestEditorFn) (*GetPlaybackChannelManifestResponse, error)

	// GetPlaybackClipManifest request
	GetPlaybackClipManifestWithResponse(ctx context.Context, clipId string, params *GetPlaybackClipManifestParams, reqEditors ...RequestEditorFn) (*GetPlaybackClipManifestResponse, error)

	// GetPlaybackProgramManifest request
	GetPlaybackProgramManifestWithResponse(ctx context.Context, programId string, params *GetPlaybackProgramManifestParams, reqEditors ...RequestEditorFn) (*GetPlaybackProgramManifestResponse, error)

	// GetPlaybackManifestRedirect request
	GetPlaybackManifestRedirectWithResponse(ctx context.Context, id string, params *GetPlaybackManifestRedirectParams, reqEditors ...RequestEditorFn) (*GetPlaybackManifestRedirectResponse, error)

	// GetPlaybackChannelMetadata request
	GetPlaybackChannelMetadataWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetPlaybackChannelMetadataResponse, error)

	// GetPlaybackClipMetadata request
	GetPlaybackClipMetadataWithResponse(ctx context.Context, clipId string, reqEditors ...RequestEditorFn) (*GetPlaybackClipMetadataResponse, error)

	// GetPlaybackProgramMetadata request
	GetPlaybackProgramMetadataWithResponse(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*GetPlaybackProgramMetadataResponse, error)

	// GetPlaybackMetadataRedirect request
	GetPlaybackMetadataRedirectWithResponse(ctx context.Context, id string, params *GetPlaybackMetadataRedirectParams, reqEditors ...RequestEditorFn) (*GetPlaybackMetadataRedirectResponse, error)
}

type GetPlaybackDebugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DebugData
}

// Status returns HTTPResponse.Status
func (r GetPlaybackDebugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackDebugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackDnsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnsList
}

// Status returns HTTPResponse.Status
func (r GetPlaybackDnsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackDnsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackChannelManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManifestResponse
}

// Status returns HTTPResponse.Status
func (r GetPlaybackChannelManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackChannelManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackClipManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManifestResponse
}

// Status returns HTTPResponse.Status
func (r GetPlaybackClipManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackClipManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackProgramManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManifestResponse
}

// Status returns HTTPResponse.Status
func (r GetPlaybackProgramManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackProgramManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackManifestRedirectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManifestResponse
}

// Status returns HTTPResponse.Status
func (r GetPlaybackManifestRedirectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackManifestRedirectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackChannelMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataResponse
}

// Status returns HTTPResponse.Status
func (r GetPlaybackChannelMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackChannelMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackClipMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataResponse
}

// Status returns HTTPResponse.Status
func (r GetPlaybackClipMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackClipMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackProgramMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataResponse
}

// Status returns HTTPResponse.Status
func (r GetPlaybackProgramMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackProgramMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackMetadataRedirectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataResponse
}

// Status returns HTTPResponse.Status
func (r GetPlaybackMetadataRedirectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackMetadataRedirectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetPlaybackDebugWithResponse request returning *GetPlaybackDebugResponse
func (c *ClientWithResponses) GetPlaybackDebugWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPlaybackDebugResponse, error) {
	rsp, err := c.GetPlaybackDebug(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackDebugResponse(rsp)
}

// GetPlaybackDnsListWithResponse request returning *GetPlaybackDnsListResponse
func (c *ClientWithResponses) GetPlaybackDnsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPlaybackDnsListResponse, error) {
	rsp, err := c.GetPlaybackDnsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackDnsListResponse(rsp)
}

// GetPlaybackChannelManifestWithResponse request returning *GetPlaybackChannelManifestResponse
func (c *ClientWithResponses) GetPlaybackChannelManifestWithResponse(ctx context.Context, channelId string, params *GetPlaybackChannelManifestParams, reqEditors ...RequestEditorFn) (*GetPlaybackChannelManifestResponse, error) {
	rsp, err := c.GetPlaybackChannelManifest(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackChannelManifestResponse(rsp)
}

// GetPlaybackClipManifestWithResponse request returning *GetPlaybackClipManifestResponse
func (c *ClientWithResponses) GetPlaybackClipManifestWithResponse(ctx context.Context, clipId string, params *GetPlaybackClipManifestParams, reqEditors ...RequestEditorFn) (*GetPlaybackClipManifestResponse, error) {
	rsp, err := c.GetPlaybackClipManifest(ctx, clipId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackClipManifestResponse(rsp)
}

// GetPlaybackProgramManifestWithResponse request returning *GetPlaybackProgramManifestResponse
func (c *ClientWithResponses) GetPlaybackProgramManifestWithResponse(ctx context.Context, programId string, params *GetPlaybackProgramManifestParams, reqEditors ...RequestEditorFn) (*GetPlaybackProgramManifestResponse, error) {
	rsp, err := c.GetPlaybackProgramManifest(ctx, programId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackProgramManifestResponse(rsp)
}

// GetPlaybackManifestRedirectWithResponse request returning *GetPlaybackManifestRedirectResponse
func (c *ClientWithResponses) GetPlaybackManifestRedirectWithResponse(ctx context.Context, id string, params *GetPlaybackManifestRedirectParams, reqEditors ...RequestEditorFn) (*GetPlaybackManifestRedirectResponse, error) {
	rsp, err := c.GetPlaybackManifestRedirect(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackManifestRedirectResponse(rsp)
}

// GetPlaybackChannelMetadataWithResponse request returning *GetPlaybackChannelMetadataResponse
func (c *ClientWithResponses) GetPlaybackChannelMetadataWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetPlaybackChannelMetadataResponse, error) {
	rsp, err := c.GetPlaybackChannelMetadata(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackChannelMetadataResponse(rsp)
}

// GetPlaybackClipMetadataWithResponse request returning *GetPlaybackClipMetadataResponse
func (c *ClientWithResponses) GetPlaybackClipMetadataWithResponse(ctx context.Context, clipId string, reqEditors ...RequestEditorFn) (*GetPlaybackClipMetadataResponse, error) {
	rsp, err := c.GetPlaybackClipMetadata(ctx, clipId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackClipMetadataResponse(rsp)
}

// GetPlaybackProgramMetadataWithResponse request returning *GetPlaybackProgramMetadataResponse
func (c *ClientWithResponses) GetPlaybackProgramMetadataWithResponse(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*GetPlaybackProgramMetadataResponse, error) {
	rsp, err := c.GetPlaybackProgramMetadata(ctx, programId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackProgramMetadataResponse(rsp)
}

// GetPlaybackMetadataRedirectWithResponse request returning *GetPlaybackMetadataRedirectResponse
func (c *ClientWithResponses) GetPlaybackMetadataRedirectWithResponse(ctx context.Context, id string, params *GetPlaybackMetadataRedirectParams, reqEditors ...RequestEditorFn) (*GetPlaybackMetadataRedirectResponse, error) {
	rsp, err := c.GetPlaybackMetadataRedirect(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackMetadataRedirectResponse(rsp)
}

// ParseGetPlaybackDebugResponse parses an HTTP response from a GetPlaybackDebugWithResponse call
func ParseGetPlaybackDebugResponse(rsp *http.Response) (*GetPlaybackDebugResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackDebugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DebugData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlaybackDnsListResponse parses an HTTP response from a GetPlaybackDnsListWithResponse call
func ParseGetPlaybackDnsListResponse(rsp *http.Response) (*GetPlaybackDnsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackDnsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlaybackChannelManifestResponse parses an HTTP response from a GetPlaybackChannelManifestWithResponse call
func ParseGetPlaybackChannelManifestResponse(rsp *http.Response) (*GetPlaybackChannelManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackChannelManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManifestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlaybackClipManifestResponse parses an HTTP response from a GetPlaybackClipManifestWithResponse call
func ParseGetPlaybackClipManifestResponse(rsp *http.Response) (*GetPlaybackClipManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackClipManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManifestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlaybackProgramManifestResponse parses an HTTP response from a GetPlaybackProgramManifestWithResponse call
func ParseGetPlaybackProgramManifestResponse(rsp *http.Response) (*GetPlaybackProgramManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackProgramManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManifestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlaybackManifestRedirectResponse parses an HTTP response from a GetPlaybackManifestRedirectWithResponse call
func ParseGetPlaybackManifestRedirectResponse(rsp *http.Response) (*GetPlaybackManifestRedirectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackManifestRedirectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManifestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlaybackChannelMetadataResponse parses an HTTP response from a GetPlaybackChannelMetadataWithResponse call
func ParseGetPlaybackChannelMetadataResponse(rsp *http.Response) (*GetPlaybackChannelMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackChannelMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlaybackClipMetadataResponse parses an HTTP response from a GetPlaybackClipMetadataWithResponse call
func ParseGetPlaybackClipMetadataResponse(rsp *http.Response) (*GetPlaybackClipMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackClipMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlaybackProgramMetadataResponse parses an HTTP response from a GetPlaybackProgramMetadataWithResponse call
func ParseGetPlaybackProgramMetadataResponse(rsp *http.Response) (*GetPlaybackProgramMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackProgramMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlaybackMetadataRedirectResponse parses an HTTP response from a GetPlaybackMetadataRedirectWithResponse call
func ParseGetPlaybackMetadataRedirectResponse(rsp *http.Response) (*GetPlaybackMetadataRedirectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackMetadataRedirectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
