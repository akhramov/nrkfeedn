// Package psapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package psapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	externalRef0 "github.com/akhramov/fattigmanns_nrk_radio/playback"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for AvailabilityStatus.
const (
	Available          AvailabilityStatus = "available"
	Coming             AvailabilityStatus = "coming"
	Expired            AvailabilityStatus = "expired"
	Expires            AvailabilityStatus = "expires"
	NotAvailableOnline AvailabilityStatus = "notAvailableOnline"
)

// Defines values for EpisodeSeasonHalLinkSeriesType.
const (
	EpisodeSeasonHalLinkSeriesTypeNews       EpisodeSeasonHalLinkSeriesType = "news"
	EpisodeSeasonHalLinkSeriesTypeSequential EpisodeSeasonHalLinkSeriesType = "sequential"
	EpisodeSeasonHalLinkSeriesTypeStandard   EpisodeSeasonHalLinkSeriesType = "standard"
	EpisodeSeasonHalLinkSeriesTypeUmbrella   EpisodeSeasonHalLinkSeriesType = "umbrella"
)

// Defines values for GeoBlockDisplayValue.
const (
	Norge  GeoBlockDisplayValue = "Norge"
	Verden GeoBlockDisplayValue = "Verden"
)

// Defines values for SeasonDisplayType.
const (
	Manual  SeasonDisplayType = "manual"
	Month   SeasonDisplayType = "month"
	Number  SeasonDisplayType = "number"
	Quarter SeasonDisplayType = "quarter"
	Year    SeasonDisplayType = "year"
)

// Defines values for SeriesType.
const (
	SeriesTypeNews       SeriesType = "news"
	SeriesTypeSequential SeriesType = "sequential"
	SeriesTypeStandard   SeriesType = "standard"
	SeriesTypeUmbrella   SeriesType = "umbrella"
)

// Defines values for SortDirection.
const (
	Asc  SortDirection = "asc"
	Desc SortDirection = "desc"
)

// Defines values for Type.
const (
	Podcast Type = "podcast"
	Series  Type = "series"
)

// AvailabilityStatus defines model for AvailabilityStatus.
type AvailabilityStatus string

// AvailabilityVm Represents the Availability of a Program based on the active usage rights.
type AvailabilityVm struct {
	// HasLabel Label should only be displayed if HasLabel is true.
	HasLabel *bool `json:"hasLabel,omitempty"`

	// Label Label to be showed to the user based on the AvailabilityStatus.
	// Example: "Tilgjengelig i morgen"
	Label  *string            `json:"label,omitempty"`
	Status AvailabilityStatus `json:"status"`
}

// Badge defines model for Badge.
type Badge struct {
	Label *string      `json:"label,omitempty"`
	Type  *interface{} `json:"type,omitempty"`
}

// Category defines model for Category.
type Category struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// ContributorVm defines model for ContributorVm.
type ContributorVm struct {
	Name []string `json:"name"`
	Role string   `json:"role"`
}

// DetailsVm defines model for DetailsVm.
type DetailsVm struct {
	AccessibilityValue string `json:"accessibilityValue"`
	DisplayValue       string `json:"displayValue"`
}

// Duration Duration of the episode. We use the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) format for duration.
type Duration struct {
	DisplayValue *string `json:"displayValue,omitempty"`
	Iso8601      *string `json:"iso8601,omitempty"`
	Seconds      *int32  `json:"seconds,omitempty"`
}

// EpisodeContext defines model for EpisodeContext.
type EpisodeContext struct {
	Links struct {
		Episode HalLink               `json:"episode"`
		Season  *EpisodeSeasonHalLink `json:"season,omitempty"`
		Self    HalLink               `json:"self"`
		Series  *HalLinkNameAndTitle  `json:"series,omitempty"`
	} `json:"_links"`
	Type Type `json:"type"`
}

// EpisodeHalLinks defines model for EpisodeHalLinks.
type EpisodeHalLinks struct {
	Favourite *HalLinkTemplated     `json:"favourite,omitempty"`
	Playback  HalLink               `json:"playback"`
	Progress  *HalLinkTemplated     `json:"progress,omitempty"`
	Season    *EpisodeSeasonHalLink `json:"season,omitempty"`
	Self      HalLink               `json:"self"`
	Series    HalLinkNameAndTitle   `json:"series"`
	Share     *HalLinkShare         `json:"share,omitempty"`
}

// EpisodeHalResource defines model for EpisodeHalResource.
type EpisodeHalResource struct {
	Links EpisodeHalLinks `json:"_links"`

	// Availability Represents the Availability of a Program based on the active usage rights.
	Availability AvailabilityVm `json:"availability"`

	// Badges Array of badges indication statuses
	Badges       *[]Badge         `json:"badges,omitempty"`
	Contributors *[]ContributorVm `json:"contributors,omitempty"`
	Date         string           `json:"date"`

	// Duration Duration of the episode. We use the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) format for duration.
	Duration          string `json:"duration"`
	DurationInSeconds *int32 `json:"durationInSeconds,omitempty"`
	EpisodeId         string `json:"episodeId"`
	Id                string `json:"id"`

	// Image The array is empty if no images are present
	Image          *[]Image `json:"image,omitempty"`
	OriginalTitle  *string  `json:"originalTitle,omitempty"`
	ProductionYear *int32   `json:"productionYear,omitempty"`

	// Titles Follows the guidelines from https://nrkconfluence.atlassian.net/l/c/y03p59M0
	Titles      Titles        `json:"titles"`
	UsageRights UsageRightsVm `json:"usageRights"`
}

// EpisodeSeasonHalLink defines model for EpisodeSeasonHalLink.
type EpisodeSeasonHalLink struct {
	Href       string                         `json:"href"`
	Name       string                         `json:"name"`
	SeriesType EpisodeSeasonHalLinkSeriesType `json:"seriesType"`
	Title      string                         `json:"title"`
}

// EpisodeSeasonHalLinkSeriesType defines model for EpisodeSeasonHalLink.SeriesType.
type EpisodeSeasonHalLinkSeriesType string

// EpisodesEpisodesHalEmbedded defines model for EpisodesEpisodesHalEmbedded.
type EpisodesEpisodesHalEmbedded struct {
	Episodes *[]EpisodeHalResource `json:"episodes,omitempty"`
}

// EpisodesHalLink Episodes link are included for `StandardSeries` and `UmbrellaSeries`. `SequentialSeries` has no notion of episodes, only seasons.
type EpisodesHalLink struct {
	Href string `json:"href"`
}

// EpisodesHalLinks defines model for EpisodesHalLinks.
type EpisodesHalLinks struct {
	Next *HalLink `json:"next,omitempty"`
	Prev *HalLink `json:"prev,omitempty"`

	// Progresses Progresses link output applies to all episodes in the given list.
	Progresses *ProgressesHalLinks `json:"progresses,omitempty"`
	Self       HalLink             `json:"self"`
}

// EpisodesHalResource defines model for EpisodesHalResource.
type EpisodesHalResource struct {
	Embedded   EpisodesEpisodesHalEmbedded `json:"_embedded"`
	Links      EpisodesHalLinks            `json:"_links"`
	SeriesType SeriesType                  `json:"seriesType"`
}

// EpisodesSeriesHalEmbedded defines model for EpisodesSeriesHalEmbedded.
type EpisodesSeriesHalEmbedded struct {
	Embedded EpisodesEpisodesHalEmbedded `json:"_embedded"`
	Links    EpisodesHalLinks            `json:"_links"`
}

// ExtraMaterialClipsHalEmbedded Aggregated info for clips
type ExtraMaterialClipsHalEmbedded struct {
	Metadata *[]struct {
		// Links Link to full metadata
		Links struct {
			Self HalLink `json:"self"`
		} `json:"_links"`
		DisplayAspectRatio externalRef0.DisplayAspectRatio `json:"displayAspectRatio"`

		// Duration Clip length. The string is formatted as https://en.wikipedia.org/wiki/ISO_8601#Durations
		Duration    string                 `json:"duration"`
		Id          string                 `json:"id"`
		Playability interface{}            `json:"playability"`
		Preplay     externalRef0.PreplayVm `json:"preplay"`
	} `json:"metadata,omitempty"`
}

// ExtraMaterialClipsHalLinks defines model for ExtraMaterialClipsHalLinks.
type ExtraMaterialClipsHalLinks struct {
	Self  HalLink `json:"self"`
	Share HalLink `json:"share"`
}

// ExtraMaterialClipsHalResource defines model for ExtraMaterialClipsHalResource.
type ExtraMaterialClipsHalResource struct {
	// Embedded Aggregated info for clips
	Embedded ExtraMaterialClipsHalEmbedded `json:"_embedded"`
	Links    ExtraMaterialClipsHalLinks    `json:"_links"`

	// TotalClips Total number of clips for the given series/podcast. The number is only an indication, and does not reflect the number of non-playable clips. I.e. do not use this field for any kind of logic.
	TotalClips int32 `json:"totalClips"`
}

// GeoBlockDisplayValue defines model for GeoBlockDisplayValue.
type GeoBlockDisplayValue string

// GeoBlockVm defines model for GeoBlockVm.
type GeoBlockVm struct {
	DisplayValue GeoBlockDisplayValue `json:"displayValue"`
	IsGeoBlocked bool                 `json:"isGeoBlocked"`
}

// HalLink defines model for HalLink.
type HalLink struct {
	Href string `json:"href"`
}

// HalLinkNameAndTitle defines model for HalLinkNameAndTitle.
type HalLinkNameAndTitle struct {
	Href  string `json:"href"`
	Name  string `json:"name"`
	Title string `json:"title"`
}

// HalLinkShare defines model for HalLinkShare.
type HalLinkShare struct {
	// Href Query param `e` for episode, `p` for podcast, `s` for series. https://radio.nrk.no/lytt?s=saann-er-du{&autoplay}
	Href      string `json:"href"`
	Templated bool   `json:"templated"`
}

// HalLinkTemplated defines model for HalLinkTemplated.
type HalLinkTemplated struct {
	Href      string `json:"href"`
	Templated bool   `json:"templated"`
}

// Image defines model for Image.
type Image struct {
	Url   string `json:"url"`
	Width int32  `json:"width"`
}

// IndexPoint defines model for IndexPoint.
type IndexPoint struct {
	Contributors *[]ContributorVm `json:"contributors,omitempty"`
	Description  *string          `json:"description,omitempty"`
	Mentioned    *[]string        `json:"mentioned,omitempty"`

	// StartPoint ISO-8601 duration calculated from the episode start time
	StartPoint  *string   `json:"startPoint,omitempty"`
	SubjectList *[]string `json:"subjectList,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// LiveElement defines model for LiveElement.
type LiveElement struct {
	ChannelId   *string `json:"channelId,omitempty"`
	Description *string `json:"description,omitempty"`

	// Duration ISO-8601 duration of the playlist element
	Duration     *string `json:"duration,omitempty"`
	ProgramId    *string `json:"programId,omitempty"`
	ProgramTitle *string `json:"programTitle,omitempty"`

	// StartPoint ISO-8601 duration calculated from the episode start time
	StartPoint *string `json:"startPoint,omitempty"`

	// StartTime DateTime formatted string
	StartTime *string `json:"startTime,omitempty"`
	Title     *string `json:"title,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// NextEpisode Applies to Standard, News and Umbrella series. The date and display value for the next upcoming episode.
type NextEpisode struct {
	Date *string `json:"date,omitempty"`

	// DisplayValue Display text for when the episode will be available
	DisplayValue *string `json:"displayValue,omitempty"`
}

// OdmCategory defines model for OdmCategory.
type OdmCategory struct {
	DisplayValue string `json:"displayValue"`
	Id           string `json:"id"`
}

// OdmContributorVm defines model for OdmContributorVm.
type OdmContributorVm struct {
	Name []string `json:"name"`
	Role string   `json:"role"`
}

// OdmProgramsHalResource defines model for OdmProgramsHalResource.
type OdmProgramsHalResource struct {
	Links ProgramsHalLinks `json:"_links"`

	// Availability Represents the Availability of a Program based on the active usage rights.
	Availability AvailabilityVm      `json:"availability"`
	Category     OdmCategory         `json:"category"`
	Contributors *[]OdmContributorVm `json:"contributors,omitempty"`
	Date         string              `json:"date"`

	// Duration Duration of the episode. We use the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) format for duration.
	Duration  Duration `json:"duration"`
	EpisodeId string   `json:"episodeId"`
	Id        string   `json:"id"`

	// Image The array is empty if no images are present
	Image       []Image       `json:"image"`
	IndexPoints *[]IndexPoint `json:"indexPoints,omitempty"`

	// Playlist Playlist only applies to ODM episodes - podcast episodes does not have playlists.
	Playlist           *[]LiveElement     `json:"playlist,omitempty"`
	ProductionYear     *int32             `json:"productionYear,omitempty"`
	ProgramInformation ProgramInformation `json:"programInformation"`

	// Titles Follows the guidelines from https://nrkconfluence.atlassian.net/l/c/y03p59M0
	Titles      Titles         `json:"titles"`
	UsageRights *UsageRightsVm `json:"usageRights,omitempty"`
}

// PodcastEpisodeHalResource defines model for PodcastEpisodeHalResource.
type PodcastEpisodeHalResource struct {
	Links ProgramsHalLinks `json:"_links"`

	// Availability Represents the Availability of a Program based on the active usage rights.
	Availability AvailabilityVm `json:"availability"`
	Category     Category       `json:"category"`
	Date         string         `json:"date"`

	// Duration Duration of the episode. We use the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) format for duration.
	Duration  Duration `json:"duration"`
	EpisodeId string   `json:"episodeId"`
	Id        string   `json:"id"`

	// Image The array is empty if no images are present
	Image []Image `json:"image"`

	// IndexPoints Podcast indexpoints use the same contract as odm index points but only Title and StartPoint will be set
	IndexPoints        *[]IndexPoint      `json:"indexPoints,omitempty"`
	ProgramInformation ProgramInformation `json:"programInformation"`

	// Titles Follows the guidelines from https://nrkconfluence.atlassian.net/l/c/y03p59M0
	Titles      Titles         `json:"titles"`
	UsageRights *UsageRightsVm `json:"usageRights,omitempty"`
}

// PodcastSeasonHalLinks defines model for PodcastSeasonHalLinks.
type PodcastSeasonHalLinks struct {
	Episodes      HalLink              `json:"episodes"`
	ExtraMaterial *HalLink             `json:"extraMaterial,omitempty"`
	Favourite     *HalLinkTemplated    `json:"favourite,omitempty"`
	Podcast       *HalLinkNameAndTitle `json:"podcast,omitempty"`
	Self          HalLink              `json:"self"`
	Series        *HalLinkNameAndTitle `json:"series,omitempty"`
	Share         *HalLinkShare        `json:"share,omitempty"`
}

// PodcastSeasonHalResource defines model for PodcastSeasonHalResource.
type PodcastSeasonHalResource struct {
	Embedded struct {
		Episodes *EpisodesSeriesHalEmbedded `json:"episodes,omitempty"`
	} `json:"_embedded"`
	Links PodcastSeasonHalLinks `json:"_links"`

	// BackdropImage The array is empty if no images are present
	BackdropImage        *[]Image `json:"backdropImage,omitempty"`
	Category             Category `json:"category"`
	EpisodeCount         float32  `json:"episodeCount"`
	HasAvailableEpisodes bool     `json:"hasAvailableEpisodes"`

	// Image The array is empty if no images are present
	Image *[]Image `json:"image,omitempty"`

	// PosterImage The array is empty if no images are present
	PosterImage *[]Image   `json:"posterImage,omitempty"`
	SeriesType  SeriesType `json:"seriesType"`

	// SquareImage The array is empty if no images are present
	SquareImage *[]Image `json:"squareImage,omitempty"`

	// Titles Follows the guidelines from https://nrkconfluence.atlassian.net/l/c/y03p59M0
	Titles Titles `json:"titles"`
	Type   Type   `json:"type"`
}

// ProgramInformation defines model for ProgramInformation.
type ProgramInformation struct {
	Details       *DetailsVm `json:"details,omitempty"`
	OriginalTitle *string    `json:"originalTitle,omitempty"`
}

// ProgramsHalLinks defines model for ProgramsHalLinks.
type ProgramsHalLinks struct {
	ExtraMaterial *HalLink              `json:"extraMaterial,omitempty"`
	Favourite     *HalLinkTemplated     `json:"favourite,omitempty"`
	Playback      HalLink               `json:"playback"`
	Progress      *HalLinkTemplated     `json:"progress,omitempty"`
	Season        *EpisodeSeasonHalLink `json:"season,omitempty"`
	Self          HalLink               `json:"self"`
	Series        *HalLinkNameAndTitle  `json:"series,omitempty"`
	Share         *HalLinkShare         `json:"share,omitempty"`
}

// ProgressesHalLink ProgressHalLink consists of a list of comma-separated programIds that we gzip, base64 and url encode to avoid exceeding character limit in the url.
type ProgressesHalLink struct {
	Href      string `json:"href"`
	Templated bool   `json:"templated"`
}

// ProgressesHalLinks Progresses link output applies to all episodes in the given list.
type ProgressesHalLinks = []ProgressesHalLink

// SeasonDisplayType defines model for SeasonDisplayType.
type SeasonDisplayType string

// SeasonHalLinks defines model for SeasonHalLinks.
type SeasonHalLinks struct {
	Episodes      HalLink              `json:"episodes"`
	ExtraMaterial *HalLink             `json:"extraMaterial,omitempty"`
	Podcast       *HalLinkNameAndTitle `json:"podcast,omitempty"`
	Self          HalLink              `json:"self"`
	Series        *HalLinkNameAndTitle `json:"series,omitempty"`
}

// SeasonHalResource defines model for SeasonHalResource.
type SeasonHalResource struct {
	Embedded struct {
		Episodes *EpisodesSeriesHalEmbedded `json:"episodes,omitempty"`
	} `json:"_embedded"`
	Links SeasonHalLinks `json:"_links"`

	// BackdropImage The array is empty if no images are present
	BackdropImage        *[]Image `json:"backdropImage,omitempty"`
	EpisodeCount         float32  `json:"episodeCount"`
	HasAvailableEpisodes bool     `json:"hasAvailableEpisodes"`

	// Image The array is empty if no images are present
	Image *[]Image `json:"image,omitempty"`

	// PosterImage The array is empty if no images are present
	PosterImage *[]Image   `json:"posterImage,omitempty"`
	SeriesType  SeriesType `json:"seriesType"`

	// SquareImage The array is empty if no images are present
	SquareImage *[]Image `json:"squareImage,omitempty"`

	// Titles Follows the guidelines from https://nrkconfluence.atlassian.net/l/c/y03p59M0
	Titles Titles `json:"titles"`
	Type   Type   `json:"type"`
}

// SeasonSeriesHalEmbedded defines model for SeasonSeriesHalEmbedded.
type SeasonSeriesHalEmbedded struct {
	Links *SeasonSeriesHalEmbeddedLinks `json:"_links,omitempty"`

	// Badges Array of badges for this season. Only "new"-badge currently supported. Only applicable for seasons in Umbrella-podcasts. Otherwise not in response.
	Badges               *[]Badge                   `json:"badges,omitempty"`
	EpisodeCount         float32                    `json:"episodeCount"`
	Episodes             *EpisodesSeriesHalEmbedded `json:"episodes,omitempty"`
	HasAvailableEpisodes bool                       `json:"hasAvailableEpisodes"`
	Id                   string                     `json:"id"`

	// Image The array is empty if no images are present
	Image *[]Image `json:"image,omitempty"`

	// NewEpisodesCount Number of new episodes in this season. Used in conjunction with `progressesForNewEpisodes`-link to check progresses for new episodes in season. New-badge should be removed if the number of new episodes matches the number of episodes with started/finished progress. Only applicable for seasons in Umbrella-podcasts. Otherwise not in response.
	NewEpisodesCount *int `json:"newEpisodesCount,omitempty"`

	// Titles Follows the guidelines from https://nrkconfluence.atlassian.net/l/c/y03p59M0
	Titles Titles `json:"titles"`
}

// SeasonSeriesHalEmbeddedLinks defines model for SeasonSeriesHalEmbeddedLinks.
type SeasonSeriesHalEmbeddedLinks struct {
	// ProgressesForNewEpisodes Links to check progresses for new episodes in season. Used in conjuction with `newEpisodesCount`. Only applicable for seasons in Umbrella-podcasts. Otherwise not in response.
	ProgressesForNewEpisodes *[]HalLinkTemplated `json:"progressesForNewEpisodes,omitempty"`
	Self                     HalLink             `json:"self"`
}

// SeriesHalEmbedded `StandardSeries` only gets episodes embedded. `SequentialSeries` gets seasons included. `UmbrellaSeries` gets both episodes and seasons included.
type SeriesHalEmbedded struct {
	Episodes *EpisodesSeriesHalEmbedded `json:"episodes,omitempty"`

	// Seasons By default 1 season is embedded. Umbrella series with seasonDisplayType 'manual' gets all seasons embedded.
	Seasons *[]SeasonSeriesHalEmbedded `json:"seasons,omitempty"`
}

// SeriesHalLinks defines model for SeriesHalLinks.
type SeriesHalLinks struct {
	// Episodes Episodes link are included for `StandardSeries` and `UmbrellaSeries`. `SequentialSeries` has no notion of episodes, only seasons.
	Episodes           *EpisodesHalLink      `json:"episodes,omitempty"`
	ExtraMaterial      *HalLink              `json:"extraMaterial,omitempty"`
	Favourite          *HalLinkTemplated     `json:"favourite,omitempty"`
	HighlightedEpisode *HalLinkTemplated     `json:"highlightedEpisode,omitempty"`
	Podcast            *HalLink              `json:"podcast,omitempty"`
	Preferred          *HalLink              `json:"preferred,omitempty"`
	Seasons            []HalLinkNameAndTitle `json:"seasons"`
	Self               HalLink               `json:"self"`
	UserData           *HalLinkTemplated     `json:"userData,omitempty"`
}

// SeriesHalResource defines model for SeriesHalResource.
type SeriesHalResource struct {
	// Embedded `StandardSeries` only gets episodes embedded. `SequentialSeries` gets seasons included. `UmbrellaSeries` gets both episodes and seasons included.
	Embedded          SeriesHalEmbedded `json:"_embedded"`
	Links             SeriesHalLinks    `json:"_links"`
	SeasonDisplayType SeasonDisplayType `json:"seasonDisplayType"`
	Series            SeriesViewModel   `json:"series"`
	SeriesType        SeriesType        `json:"seriesType"`
	Type              Type              `json:"type"`
}

// SeriesType defines model for SeriesType.
type SeriesType string

// SeriesTypeHalLinks defines model for SeriesTypeHalLinks.
type SeriesTypeHalLinks struct {
	Self HalLink `json:"self"`
}

// SeriesTypeHalResource defines model for SeriesTypeHalResource.
type SeriesTypeHalResource struct {
	Links      SeriesTypeHalLinks `json:"_links"`
	SeriesType SeriesType         `json:"seriesType"`
}

// SeriesViewModel defines model for SeriesViewModel.
type SeriesViewModel struct {
	// BackdropImage The array is empty if no images are present
	BackdropImage      []Image  `json:"backdropImage"`
	Category           Category `json:"category"`
	HighlightedEpisode *string  `json:"highlightedEpisode,omitempty"`
	Id                 string   `json:"id"`

	// Image The array is empty if no images are present
	Image []Image `json:"image"`

	// NextEpisode Applies to Standard, News and Umbrella series. The date and display value for the next upcoming episode.
	NextEpisode *NextEpisode `json:"nextEpisode,omitempty"`

	// PosterImage The array is empty if no images are present
	PosterImage []Image `json:"posterImage"`

	// SquareImage The array is empty if no images are present
	SquareImage []Image `json:"squareImage"`

	// Titles Follows the guidelines from https://nrkconfluence.atlassian.net/l/c/y03p59M0
	Titles Titles `json:"titles"`
}

// SortDirection defines model for SortDirection.
type SortDirection string

// Titles Follows the guidelines from https://nrkconfluence.atlassian.net/l/c/y03p59M0
type Titles struct {
	Subtitle *string `json:"subtitle"`
	Title    string  `json:"title"`
}

// Type defines model for Type.
type Type string

// UsageRightsDateVm defines model for UsageRightsDateVm.
type UsageRightsDateVm struct {
	Date         string `json:"date"`
	DisplayValue string `json:"displayValue"`
}

// UsageRightsVm defines model for UsageRightsVm.
type UsageRightsVm struct {
	From     UsageRightsDateVm `json:"from"`
	GeoBlock GeoBlockVm        `json:"geoBlock"`
	To       UsageRightsDateVm `json:"to"`
}

// GetExtramaterialClipsParams defines parameters for GetExtramaterialClips.
type GetExtramaterialClipsParams struct {
	// PageSize Number of clips returned. Default is 10
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Page Which page to take from. Default is 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Sort Sorts videos by date. Default is 'desc'
	Sort *SortDirection `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPodcastParams defines parameters for GetPodcast.
type GetPodcastParams struct {
	// PageSize Default is 10.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// GetPodcastepisodesParams defines parameters for GetPodcastepisodes.
type GetPodcastepisodesParams struct {
	// PageSize Number of episodes returned. Default is 10
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Page Which page to take from
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Sort Sorts episodes by date (only applies for standard series episodes)
	Sort *SortDirection `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPodcastSeasonEpisodesParams defines parameters for GetPodcastSeasonEpisodes.
type GetPodcastSeasonEpisodesParams struct {
	// PageSize Number of episodes returned. Default is 10
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Page Which page to take from
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Sort Sorts episodes by date (only applies for standard series episodes)
	Sort *SortDirection `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetSeriesParams defines parameters for GetSeries.
type GetSeriesParams struct {
	// PageSize This parameter only affects Standard and News Series. Default is 10.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// GetSeriesepisodesParams defines parameters for GetSeriesepisodes.
type GetSeriesepisodesParams struct {
	// PageSize Number of episodes returned. Default is 10
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Page Which page to take from
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Sort Sorts episodes by date (Only applies for standard series episodes)
	Sort *SortDirection `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetSeriesSeasonEpisodesParams defines parameters for GetSeriesSeasonEpisodes.
type GetSeriesSeasonEpisodesParams struct {
	// PageSize Number of episodes returned. Default is 10
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Page Which page to take from
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Sort Sorts episodes by date (only applies for standard series episodes)
	Sort *SortDirection `form:"sort,omitempty" json:"sort,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetEpisodeContext request
	GetEpisodeContext(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtramaterialClips request
	GetExtramaterialClips(ctx context.Context, id string, params *GetExtramaterialClipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPodcast request
	GetPodcast(ctx context.Context, podcastId string, params *GetPodcastParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPodcastepisodes request
	GetPodcastepisodes(ctx context.Context, podcastId string, params *GetPodcastepisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPodcastEpisode request
	GetPodcastEpisode(ctx context.Context, podcastId string, podcastEpisodeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPodcastSeason request
	GetPodcastSeason(ctx context.Context, podcastId string, seasonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPodcastSeasonEpisodes request
	GetPodcastSeasonEpisodes(ctx context.Context, podcastId string, seasonId string, params *GetPodcastSeasonEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgram request
	GetProgram(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgramContext request
	GetProgramContext(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeries request
	GetSeries(ctx context.Context, seriesId string, params *GetSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesepisodes request
	GetSeriesepisodes(ctx context.Context, seriesId string, params *GetSeriesepisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesSeason request
	GetSeriesSeason(ctx context.Context, seriesId string, seasonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesSeasonEpisodes request
	GetSeriesSeasonEpisodes(ctx context.Context, seriesId string, seasonId string, params *GetSeriesSeasonEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesType request
	GetSeriesType(ctx context.Context, seriesId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersion request
	GetVersion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetEpisodeContext(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEpisodeContextRequest(c.Server, episodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtramaterialClips(ctx context.Context, id string, params *GetExtramaterialClipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtramaterialClipsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPodcast(ctx context.Context, podcastId string, params *GetPodcastParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPodcastRequest(c.Server, podcastId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPodcastepisodes(ctx context.Context, podcastId string, params *GetPodcastepisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPodcastepisodesRequest(c.Server, podcastId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPodcastEpisode(ctx context.Context, podcastId string, podcastEpisodeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPodcastEpisodeRequest(c.Server, podcastId, podcastEpisodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPodcastSeason(ctx context.Context, podcastId string, seasonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPodcastSeasonRequest(c.Server, podcastId, seasonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPodcastSeasonEpisodes(ctx context.Context, podcastId string, seasonId string, params *GetPodcastSeasonEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPodcastSeasonEpisodesRequest(c.Server, podcastId, seasonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgram(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramRequest(c.Server, programId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgramContext(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramContextRequest(c.Server, programId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeries(ctx context.Context, seriesId string, params *GetSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesRequest(c.Server, seriesId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesepisodes(ctx context.Context, seriesId string, params *GetSeriesepisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesepisodesRequest(c.Server, seriesId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesSeason(ctx context.Context, seriesId string, seasonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesSeasonRequest(c.Server, seriesId, seasonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesSeasonEpisodes(ctx context.Context, seriesId string, seasonId string, params *GetSeriesSeasonEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesSeasonEpisodesRequest(c.Server, seriesId, seasonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesType(ctx context.Context, seriesId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesTypeRequest(c.Server, seriesId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetEpisodeContextRequest generates requests for GetEpisodeContext
func NewGetEpisodeContextRequest(server string, episodeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "episodeId", runtime.ParamLocationPath, episodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/episode/context/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExtramaterialClipsRequest generates requests for GetExtramaterialClips
func NewGetExtramaterialClipsRequest(server string, id string, params *GetExtramaterialClipsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/extramaterial/%s/clips", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPodcastRequest generates requests for GetPodcast
func NewGetPodcastRequest(server string, podcastId string, params *GetPodcastParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "podcastId", runtime.ParamLocationPath, podcastId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/podcast/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPodcastepisodesRequest generates requests for GetPodcastepisodes
func NewGetPodcastepisodesRequest(server string, podcastId string, params *GetPodcastepisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "podcastId", runtime.ParamLocationPath, podcastId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/podcast/%s/episodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPodcastEpisodeRequest generates requests for GetPodcastEpisode
func NewGetPodcastEpisodeRequest(server string, podcastId string, podcastEpisodeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "podcastId", runtime.ParamLocationPath, podcastId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "podcastEpisodeId", runtime.ParamLocationPath, podcastEpisodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/podcast/%s/episodes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPodcastSeasonRequest generates requests for GetPodcastSeason
func NewGetPodcastSeasonRequest(server string, podcastId string, seasonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "podcastId", runtime.ParamLocationPath, podcastId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "seasonId", runtime.ParamLocationPath, seasonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/podcast/%s/seasons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPodcastSeasonEpisodesRequest generates requests for GetPodcastSeasonEpisodes
func NewGetPodcastSeasonEpisodesRequest(server string, podcastId string, seasonId string, params *GetPodcastSeasonEpisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "podcastId", runtime.ParamLocationPath, podcastId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "seasonId", runtime.ParamLocationPath, seasonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/podcast/%s/seasons/%s/episodes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramRequest generates requests for GetProgram
func NewGetProgramRequest(server string, programId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "programId", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramContextRequest generates requests for GetProgramContext
func NewGetProgramContextRequest(server string, programId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "programId", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/programsContext/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesRequest generates requests for GetSeries
func NewGetSeriesRequest(server string, seriesId string, params *GetSeriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "seriesId", runtime.ParamLocationPath, seriesId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/series/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesepisodesRequest generates requests for GetSeriesepisodes
func NewGetSeriesepisodesRequest(server string, seriesId string, params *GetSeriesepisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "seriesId", runtime.ParamLocationPath, seriesId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/series/%s/episodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesSeasonRequest generates requests for GetSeriesSeason
func NewGetSeriesSeasonRequest(server string, seriesId string, seasonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "seriesId", runtime.ParamLocationPath, seriesId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "seasonId", runtime.ParamLocationPath, seasonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/series/%s/seasons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesSeasonEpisodesRequest generates requests for GetSeriesSeasonEpisodes
func NewGetSeriesSeasonEpisodesRequest(server string, seriesId string, seasonId string, params *GetSeriesSeasonEpisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "seriesId", runtime.ParamLocationPath, seriesId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "seasonId", runtime.ParamLocationPath, seasonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/series/%s/seasons/%s/episodes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesTypeRequest generates requests for GetSeriesType
func NewGetSeriesTypeRequest(server string, seriesId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "seriesId", runtime.ParamLocationPath, seriesId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/series/%s/type", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionRequest generates requests for GetVersion
func NewGetVersionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radio/catalog/version/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetEpisodeContext request
	GetEpisodeContextWithResponse(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*GetEpisodeContextResponse, error)

	// GetExtramaterialClips request
	GetExtramaterialClipsWithResponse(ctx context.Context, id string, params *GetExtramaterialClipsParams, reqEditors ...RequestEditorFn) (*GetExtramaterialClipsResponse, error)

	// GetPodcast request
	GetPodcastWithResponse(ctx context.Context, podcastId string, params *GetPodcastParams, reqEditors ...RequestEditorFn) (*GetPodcastResponse, error)

	// GetPodcastepisodes request
	GetPodcastepisodesWithResponse(ctx context.Context, podcastId string, params *GetPodcastepisodesParams, reqEditors ...RequestEditorFn) (*GetPodcastepisodesResponse, error)

	// GetPodcastEpisode request
	GetPodcastEpisodeWithResponse(ctx context.Context, podcastId string, podcastEpisodeId string, reqEditors ...RequestEditorFn) (*GetPodcastEpisodeResponse, error)

	// GetPodcastSeason request
	GetPodcastSeasonWithResponse(ctx context.Context, podcastId string, seasonId string, reqEditors ...RequestEditorFn) (*GetPodcastSeasonResponse, error)

	// GetPodcastSeasonEpisodes request
	GetPodcastSeasonEpisodesWithResponse(ctx context.Context, podcastId string, seasonId string, params *GetPodcastSeasonEpisodesParams, reqEditors ...RequestEditorFn) (*GetPodcastSeasonEpisodesResponse, error)

	// GetProgram request
	GetProgramWithResponse(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*GetProgramResponse, error)

	// GetProgramContext request
	GetProgramContextWithResponse(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*GetProgramContextResponse, error)

	// GetSeries request
	GetSeriesWithResponse(ctx context.Context, seriesId string, params *GetSeriesParams, reqEditors ...RequestEditorFn) (*GetSeriesResponse, error)

	// GetSeriesepisodes request
	GetSeriesepisodesWithResponse(ctx context.Context, seriesId string, params *GetSeriesepisodesParams, reqEditors ...RequestEditorFn) (*GetSeriesepisodesResponse, error)

	// GetSeriesSeason request
	GetSeriesSeasonWithResponse(ctx context.Context, seriesId string, seasonId string, reqEditors ...RequestEditorFn) (*GetSeriesSeasonResponse, error)

	// GetSeriesSeasonEpisodes request
	GetSeriesSeasonEpisodesWithResponse(ctx context.Context, seriesId string, seasonId string, params *GetSeriesSeasonEpisodesParams, reqEditors ...RequestEditorFn) (*GetSeriesSeasonEpisodesResponse, error)

	// GetSeriesType request
	GetSeriesTypeWithResponse(ctx context.Context, seriesId string, reqEditors ...RequestEditorFn) (*GetSeriesTypeResponse, error)

	// GetVersion request
	GetVersionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVersionResponse, error)
}

type GetEpisodeContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EpisodeContext
}

// Status returns HTTPResponse.Status
func (r GetEpisodeContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEpisodeContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtramaterialClipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExtraMaterialClipsHalResource
}

// Status returns HTTPResponse.Status
func (r GetExtramaterialClipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtramaterialClipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPodcastResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SeriesHalResource
}

// Status returns HTTPResponse.Status
func (r GetPodcastResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPodcastResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPodcastepisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EpisodesHalResource
}

// Status returns HTTPResponse.Status
func (r GetPodcastepisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPodcastepisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPodcastEpisodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PodcastEpisodeHalResource
}

// Status returns HTTPResponse.Status
func (r GetPodcastEpisodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPodcastEpisodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPodcastSeasonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PodcastSeasonHalResource
}

// Status returns HTTPResponse.Status
func (r GetPodcastSeasonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPodcastSeasonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPodcastSeasonEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EpisodesHalResource
}

// Status returns HTTPResponse.Status
func (r GetPodcastSeasonEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPodcastSeasonEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OdmProgramsHalResource
}

// Status returns HTTPResponse.Status
func (r GetProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EpisodeContext
}

// Status returns HTTPResponse.Status
func (r GetProgramContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SeriesHalResource
}

// Status returns HTTPResponse.Status
func (r GetSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesepisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EpisodesHalResource
}

// Status returns HTTPResponse.Status
func (r GetSeriesepisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesepisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesSeasonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SeasonHalResource
}

// Status returns HTTPResponse.Status
func (r GetSeriesSeasonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesSeasonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesSeasonEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EpisodesHalResource
}

// Status returns HTTPResponse.Status
func (r GetSeriesSeasonEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesSeasonEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SeriesTypeHalResource
}

// Status returns HTTPResponse.Status
func (r GetSeriesTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SeriesHalResource
}

// Status returns HTTPResponse.Status
func (r GetVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetEpisodeContextWithResponse request returning *GetEpisodeContextResponse
func (c *ClientWithResponses) GetEpisodeContextWithResponse(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*GetEpisodeContextResponse, error) {
	rsp, err := c.GetEpisodeContext(ctx, episodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEpisodeContextResponse(rsp)
}

// GetExtramaterialClipsWithResponse request returning *GetExtramaterialClipsResponse
func (c *ClientWithResponses) GetExtramaterialClipsWithResponse(ctx context.Context, id string, params *GetExtramaterialClipsParams, reqEditors ...RequestEditorFn) (*GetExtramaterialClipsResponse, error) {
	rsp, err := c.GetExtramaterialClips(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExtramaterialClipsResponse(rsp)
}

// GetPodcastWithResponse request returning *GetPodcastResponse
func (c *ClientWithResponses) GetPodcastWithResponse(ctx context.Context, podcastId string, params *GetPodcastParams, reqEditors ...RequestEditorFn) (*GetPodcastResponse, error) {
	rsp, err := c.GetPodcast(ctx, podcastId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPodcastResponse(rsp)
}

// GetPodcastepisodesWithResponse request returning *GetPodcastepisodesResponse
func (c *ClientWithResponses) GetPodcastepisodesWithResponse(ctx context.Context, podcastId string, params *GetPodcastepisodesParams, reqEditors ...RequestEditorFn) (*GetPodcastepisodesResponse, error) {
	rsp, err := c.GetPodcastepisodes(ctx, podcastId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPodcastepisodesResponse(rsp)
}

// GetPodcastEpisodeWithResponse request returning *GetPodcastEpisodeResponse
func (c *ClientWithResponses) GetPodcastEpisodeWithResponse(ctx context.Context, podcastId string, podcastEpisodeId string, reqEditors ...RequestEditorFn) (*GetPodcastEpisodeResponse, error) {
	rsp, err := c.GetPodcastEpisode(ctx, podcastId, podcastEpisodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPodcastEpisodeResponse(rsp)
}

// GetPodcastSeasonWithResponse request returning *GetPodcastSeasonResponse
func (c *ClientWithResponses) GetPodcastSeasonWithResponse(ctx context.Context, podcastId string, seasonId string, reqEditors ...RequestEditorFn) (*GetPodcastSeasonResponse, error) {
	rsp, err := c.GetPodcastSeason(ctx, podcastId, seasonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPodcastSeasonResponse(rsp)
}

// GetPodcastSeasonEpisodesWithResponse request returning *GetPodcastSeasonEpisodesResponse
func (c *ClientWithResponses) GetPodcastSeasonEpisodesWithResponse(ctx context.Context, podcastId string, seasonId string, params *GetPodcastSeasonEpisodesParams, reqEditors ...RequestEditorFn) (*GetPodcastSeasonEpisodesResponse, error) {
	rsp, err := c.GetPodcastSeasonEpisodes(ctx, podcastId, seasonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPodcastSeasonEpisodesResponse(rsp)
}

// GetProgramWithResponse request returning *GetProgramResponse
func (c *ClientWithResponses) GetProgramWithResponse(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*GetProgramResponse, error) {
	rsp, err := c.GetProgram(ctx, programId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramResponse(rsp)
}

// GetProgramContextWithResponse request returning *GetProgramContextResponse
func (c *ClientWithResponses) GetProgramContextWithResponse(ctx context.Context, programId string, reqEditors ...RequestEditorFn) (*GetProgramContextResponse, error) {
	rsp, err := c.GetProgramContext(ctx, programId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramContextResponse(rsp)
}

// GetSeriesWithResponse request returning *GetSeriesResponse
func (c *ClientWithResponses) GetSeriesWithResponse(ctx context.Context, seriesId string, params *GetSeriesParams, reqEditors ...RequestEditorFn) (*GetSeriesResponse, error) {
	rsp, err := c.GetSeries(ctx, seriesId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesResponse(rsp)
}

// GetSeriesepisodesWithResponse request returning *GetSeriesepisodesResponse
func (c *ClientWithResponses) GetSeriesepisodesWithResponse(ctx context.Context, seriesId string, params *GetSeriesepisodesParams, reqEditors ...RequestEditorFn) (*GetSeriesepisodesResponse, error) {
	rsp, err := c.GetSeriesepisodes(ctx, seriesId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesepisodesResponse(rsp)
}

// GetSeriesSeasonWithResponse request returning *GetSeriesSeasonResponse
func (c *ClientWithResponses) GetSeriesSeasonWithResponse(ctx context.Context, seriesId string, seasonId string, reqEditors ...RequestEditorFn) (*GetSeriesSeasonResponse, error) {
	rsp, err := c.GetSeriesSeason(ctx, seriesId, seasonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesSeasonResponse(rsp)
}

// GetSeriesSeasonEpisodesWithResponse request returning *GetSeriesSeasonEpisodesResponse
func (c *ClientWithResponses) GetSeriesSeasonEpisodesWithResponse(ctx context.Context, seriesId string, seasonId string, params *GetSeriesSeasonEpisodesParams, reqEditors ...RequestEditorFn) (*GetSeriesSeasonEpisodesResponse, error) {
	rsp, err := c.GetSeriesSeasonEpisodes(ctx, seriesId, seasonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesSeasonEpisodesResponse(rsp)
}

// GetSeriesTypeWithResponse request returning *GetSeriesTypeResponse
func (c *ClientWithResponses) GetSeriesTypeWithResponse(ctx context.Context, seriesId string, reqEditors ...RequestEditorFn) (*GetSeriesTypeResponse, error) {
	rsp, err := c.GetSeriesType(ctx, seriesId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesTypeResponse(rsp)
}

// GetVersionWithResponse request returning *GetVersionResponse
func (c *ClientWithResponses) GetVersionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVersionResponse, error) {
	rsp, err := c.GetVersion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionResponse(rsp)
}

// ParseGetEpisodeContextResponse parses an HTTP response from a GetEpisodeContextWithResponse call
func ParseGetEpisodeContextResponse(rsp *http.Response) (*GetEpisodeContextResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEpisodeContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EpisodeContext
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExtramaterialClipsResponse parses an HTTP response from a GetExtramaterialClipsWithResponse call
func ParseGetExtramaterialClipsResponse(rsp *http.Response) (*GetExtramaterialClipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExtramaterialClipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExtraMaterialClipsHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPodcastResponse parses an HTTP response from a GetPodcastWithResponse call
func ParseGetPodcastResponse(rsp *http.Response) (*GetPodcastResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPodcastResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SeriesHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPodcastepisodesResponse parses an HTTP response from a GetPodcastepisodesWithResponse call
func ParseGetPodcastepisodesResponse(rsp *http.Response) (*GetPodcastepisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPodcastepisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EpisodesHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPodcastEpisodeResponse parses an HTTP response from a GetPodcastEpisodeWithResponse call
func ParseGetPodcastEpisodeResponse(rsp *http.Response) (*GetPodcastEpisodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPodcastEpisodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PodcastEpisodeHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPodcastSeasonResponse parses an HTTP response from a GetPodcastSeasonWithResponse call
func ParseGetPodcastSeasonResponse(rsp *http.Response) (*GetPodcastSeasonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPodcastSeasonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PodcastSeasonHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPodcastSeasonEpisodesResponse parses an HTTP response from a GetPodcastSeasonEpisodesWithResponse call
func ParseGetPodcastSeasonEpisodesResponse(rsp *http.Response) (*GetPodcastSeasonEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPodcastSeasonEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EpisodesHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProgramResponse parses an HTTP response from a GetProgramWithResponse call
func ParseGetProgramResponse(rsp *http.Response) (*GetProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OdmProgramsHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProgramContextResponse parses an HTTP response from a GetProgramContextWithResponse call
func ParseGetProgramContextResponse(rsp *http.Response) (*GetProgramContextResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EpisodeContext
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesResponse parses an HTTP response from a GetSeriesWithResponse call
func ParseGetSeriesResponse(rsp *http.Response) (*GetSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SeriesHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesepisodesResponse parses an HTTP response from a GetSeriesepisodesWithResponse call
func ParseGetSeriesepisodesResponse(rsp *http.Response) (*GetSeriesepisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesepisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EpisodesHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesSeasonResponse parses an HTTP response from a GetSeriesSeasonWithResponse call
func ParseGetSeriesSeasonResponse(rsp *http.Response) (*GetSeriesSeasonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesSeasonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SeasonHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesSeasonEpisodesResponse parses an HTTP response from a GetSeriesSeasonEpisodesWithResponse call
func ParseGetSeriesSeasonEpisodesResponse(rsp *http.Response) (*GetSeriesSeasonEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesSeasonEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EpisodesHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesTypeResponse parses an HTTP response from a GetSeriesTypeWithResponse call
func ParseGetSeriesTypeResponse(rsp *http.Response) (*GetSeriesTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SeriesTypeHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVersionResponse parses an HTTP response from a GetVersionWithResponse call
func ParseGetVersionResponse(rsp *http.Response) (*GetVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SeriesHalResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
